/**
 * Generated by orval v6.27.1 üç∫
 * Do not edit manually.
 * Embedded Finance API
 * Embedded Finance services from J.P. Morgan
 * OpenAPI spec version: 0.9.88
 */
export type GetAccountsParams = {
/**
 * Unique client identifier
 */
clientId?: ClientIdParamParameter;
/**
 * Number of records per page.
 */
limit?: PageSizeParameter;
/**
 * Page Number
 */
page?: PageNoParameter;
};

export type GetAllRolesParams = {
/**
 * Number of records per page.
 */
limit?: UserPageSizeParameter;
/**
 * Page Number
 */
page?: UserPageNoParameter;
/**
 * Role id
 */
roleId?: UserRoleParameter;
};

export type GetAllUsersParams = {
/**
 * Determines the fetch level.<br><br>
USER_STATUS: Fetches user status from identity provided<br><br>
PARTY: Fetches party information for user like names, address, phones etc.<br><br>
ROLES: Fetches user role information<br>
 */
fetchLevel?: UserFetchLevelParameter;
/**
 * Number of records per page.
 */
limit?: UserPageSizeParameter;
/**
 * Page Number
 */
page?: UserPageNoParameter;
};

export type SearchStatementsParams = {
/**
 * Account identifiers used to represent client accounts.

 */
accountIds?: string[];
/**
 * Earliest date in search range. Must be set at least one day earlier than dateTo.
 */
dateFrom: string;
/**
 * Latest date in search range. Must be set at least one day later than dateFrom.
 */
dateTo: string;
};

export type GetClientIndustryCategoriesParams = {
/**
 * Number of records per page.
 */
limit?: PageSizeParameter;
/**
 * Page Number
 */
page?: PageNoParameter;
};

export type GetDocumentTypesParams = {
/**
 * Two-letter ISO code for a country, such as US for USA.
 */
countryCode?: CountryCodeParameter;
/**
 * Document category type.
 */
documentCategory?: DocumentCategoryParameter;
/**
 * url encoded legalStructure type.
 */
legalStructure?: LegalStructureParameter;
/**
 * Number of records per page.
 */
limit?: PageSizeParameter;
/**
 * Page Number
 */
page?: PageNoParameter;
};

export type GetCountrySubdivisionParams = {
/**
 * Two-letter ISO code for a country, such as US for USA.
 */
countryCode?: CountryCodeParameter;
/**
 * Number of records per page.
 */
limit?: PageSizeParameter;
/**
 * Page Number
 */
page?: PageNoParameter;
};

export type ListWebhooksParams = {
/**
 * Page Number
 */
page?: PageNoParameter;
/**
 * Number of records per page.
 */
limit?: PageSizeParameter;
};

export type GetFaqParams = {
/**
 * Unique Client identifier
 */
clientId?: ClientIdInQueryParameter;
/**
 * Comma seperated tag values
 */
tags?: string[];
};

export type GetAllRecipientsParams = {
/**
 * Unique Client identifier
 */
clientId?: ClientIdInQueryParameter;
/**
 * Recipient type to return
 */
type?: RecipientType;
/**
 * Number of records per page.
 */
limit?: PageSizeParameter;
/**
 * Page Number
 */
page?: PageNoParameter;
};

export type GetDebitCardsParams = {
/**
 * Current page number.
 */
page?: number;
/**
 * Number of records per page.
 */
limit?: number;
};

export type ListPaymentIntentsParams = {
/**
 * Recipient ID
 */
recipientId?: string;
/**
 * Payment intent status
 */
status?: string;
};

export type GetBalanceHolds1Params = {
/**
 * Unique account identifier
 */
id: AccountIdInQueryParameter;
/**
 * Page Number
 */
page?: PageNoParameter;
/**
 * Number of records per page.
 */
limit?: PageSizeParameter;
};

export type GetBalanceHoldsParams = {
/**
 * Account ID
 */
accountId: string;
};

export type SmbdoDownloadDocument200Six = { [key: string]: any };

export type SmbdoGetAllDocumentDetailsParams = {
/**
 * Unique Client identifier
 */
clientId?: ClientIdInQueryParameter;
/**
 * Unique Party identifier.
 */
partyId?: PartyIdQueryParameter;
/**
 * Unique identifier for the platform.
 */
platformId?: PlatformIdInQueryParameter;
/**
 * Page Number
 */
page?: PageNoParameter;
/**
 * Number of records per page.
 */
limit?: PageSizeParameter;
};

export type SmbdoListDocumentRequestsParams = {
/**
 * Unique Client identifier.
 */
clientId?: ClientIdQueryParameter;
/**
 * Unique Party identifier.
 */
partyId?: PartyIdQueryParameter;
};

export type SmbdoListQuestionsParams = {
/**
 * Comma-separated list of Question IDs.
 */
questionIds?: QuestionIdListInQueryParameter;
};

export type SmbdoListPartiesParams = {
/**
 * Number of records per page.
 */
limit?: PageSizeParameter;
/**
 * Page Number
 */
page?: PageNoParameter;
/**
 * ID of the parent party.
 */
parentPartyId?: ParentPartyIdParameter;
};

export type SmbdoListClientsParams = {
/**
 * Number of records per page.
 */
limit?: PageSizeParameter;
/**
 * Page Number
 */
page?: PageNoParameter;
};

export type ListTransactionsParams = {
/**
 * Filters by type of transaction.
 */
transactionType?: RequestTransactionType;
/**
 * Filters by transaction status.
 */
status?: RequestTransactionStatus;
/**
 * Filters by the Embedded Banking client account number connected to the transaction.
 */
accountNumber?: string;
/**
 * Filters by an exact amount.
 */
amountEquals?: string;
/**
 * Filters by amounts greater than a specified value.
 */
amountGreaterThan?: string;
/**
 * Filters by amounts less than a specified value.
 */
amountLessThan?: string;
/**
 * Filters transactions by an exact date.
 */
dateEquals?: string;
/**
 * Filters for transactions made after this date.
 */
dateGreaterThan?: string;
/**
 * Filters for transactions made before this date.
 */
dateLessThan?: string;
/**
 * Filters for transactions made after this date and time.
 */
dateTimeGreaterThan?: string;
/**
 * Filters for transactions made before this date and time.
 */
dateTimeLessThan?: string;
/**
 * Filters by the recipient's account number.
 */
recipientAccount?: string;
/**
 * Filters for a transaction that matches a specific transaction ID. The transaction ID is generated by Embedded Banking when a transaction is created or received.
 */
transactionId?: string;
};

export type ListTransactionsV2Params = {
/**
 * Filters by type of transaction.
 */
type?: RequestTransactionTypeV2;
/**
 * Filters by transaction status.
 */
status?: RequestTransactionStatus;
/**
 * Filters by the Embedded Finance account id connected to the transaction.
 */
accountId?: string;
/**
 * Filters by an exact amount.
 */
amountEquals?: string;
/**
 * Filters by amounts greater than a specified value.
 */
amountGreaterThan?: string;
/**
 * Filters by amounts less than a specified value.
 */
amountLessThan?: string;
/**
 * Filters transactions by an exact date.
 */
dateEquals?: string;
/**
 * Filters for transactions made after this payment date.
 */
dateGreaterThan?: string;
/**
 * Filters for transactions made before this payment date.
 */
dateLessThan?: string;
/**
 * Filters for transactions created after this date and time.
 */
dateTimeGreaterThan?: string;
/**
 * Filters for transactions created before this date and time.
 */
dateTimeLessThan?: string;
/**
 * Filters for transactions from/to this recipientId.
 */
recipientId?: string;
/**
 * Filters for a transaction that matches a specific transaction reference ID provided by the client.
 */
transactionReferenceId?: string;
/**
 * Filters for transactions from/to this clientId.
 */
clientId?: string;
};

export type DocumentsDetailsParams = {
/**
 * The type of document. Can be terms and conditions or disclosure and consent documents.
 */
type: DocumentTypeParameter;
/**
 * Number of records per page.
 */
limit?: PageSizeParameter;
/**
 * Page Number
 */
page?: PageNoParameter;
};

export type GetAllClientsParams = {
/**
 * Number of records per page.
 */
limit?: PageSizeParameter;
/**
 * Page Number
 */
page?: PageNoParameter;
};

/**
 * Role id
 */
export type UserRoleParameter = string;

/**
 * Page Number
 */
export type UserPageNoParameter = number;

/**
 * Number of records per page.
 */
export type UserPageSizeParameter = number;

/**
 * Determines the fetch level.<br><br>
USER_STATUS: Fetches user status from identity provided<br><br>
PARTY: Fetches party information for user like names, address, phones etc.<br><br>
ROLES: Fetches user role information<br>
 */
export type UserFetchLevelParameter = FetchLevel[];

/**
 * Unique identifier for the platform.
 */
export type PlatformIdInQueryParameter = string;

/**
 * Unique Client identifier
 */
export type ClientIdInQueryParameter = string;

export type DocumentTypeParameter = typeof DocumentTypeParameter[keyof typeof DocumentTypeParameter];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DocumentTypeParameter = {
  TERMS_CONDITION: 'TERMS_CONDITION',
  DISCLOSURE_AND_CONSENT: 'DISCLOSURE_AND_CONSENT',
} as const;

/**
 * Page Number
 */
export type PageNoParameter = number;

/**
 * Number of records per page.
 */
export type PageSizeParameter = number;

/**
 * Unique client identifier
 */
export type ClientIdParamParameter = string;

export type ProductParameter = typeof ProductParameter[keyof typeof ProductParameter];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProductParameter = {
  EB: 'EB',
  EP: 'EP',
} as const;

/**
 * url encoded legalStructure type.
 */
export type LegalStructureParameter = string;

export type DocumentCategoryParameter = typeof DocumentCategoryParameter[keyof typeof DocumentCategoryParameter];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DocumentCategoryParameter = {
  IDENTITY_VERIFICATION: 'IDENTITY_VERIFICATION',
} as const;

/**
 * Two-letter ISO code for a country, such as US for USA.
 */
export type CountryCodeParameter = string;

/**
 * Unique account identifier
 */
export type AccountIdInQueryParameter = string;

/**
 * Comma-separated list of Question IDs.
 */
export type QuestionIdListInQueryParameter = string;

/**
 * Unique Party identifier.
 */
export type PartyIdQueryParameter = string;

/**
 * ID of the parent party.
 */
export type ParentPartyIdParameter = string;

/**
 * Unique Client identifier.
 */
export type ClientIdQueryParameter = string;

export type CaseViewGroupParameter = typeof CaseViewGroupParameter[keyof typeof CaseViewGroupParameter];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CaseViewGroupParameter = {
  OPEN: 'OPEN',
  ARCHIVED: 'ARCHIVED',
} as const;

export type SummaryTypeParameter = typeof SummaryTypeParameter[keyof typeof SummaryTypeParameter];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SummaryTypeParameter = {
  INTRADAY: 'INTRADAY',
  END_OF_DAY: 'END_OF_DAY',
} as const;

/**
 * Recon To date
 */
export type ReconToDateParameter = string;

/**
 * Recon From date
 */
export type ReconFromDateParameter = string;

/**
 * No data found for the criteria specified
 */
export type User404Response = SchemasApiError;

/**
 * Bad Request
 */
export type User400Response = SchemasApiError;

/**
 * Service Unavailable - API Processing Error
 */
export type User503Response = SchemasApiError;

/**
 * Service not implemented
 */
export type User501Response = SchemasApiError;

/**
 * Internal Server Error - Generic Error
 */
export type User500Response = SchemasApiError;

/**
 * Forbidden
 */
export type User403Response = SchemasApiError;

/**
 * Unauthorized
 */
export type User401Response = SchemasApiError;

/**
 * Bad Request
 */
export type User400ClientIdResponse = SchemasApiError;

/**
 * Unprocessable Entity
 */
export type N422DoResponse = ApiErrorV2;

/**
 * Service Unavailable
 */
export type N503DoResponse = ApiErrorV2;

/**
 * Internal Server Error
 */
export type N500DoResponse = ApiErrorV2;

/**
 * Not Found
 */
export type N404DoResponse = ApiErrorV2;

/**
 * Forbidden
 */
export type N403DoResponse = ApiErrorV2;

/**
 * Unauthenticated
 */
export type N401DoResponse = ApiErrorV2;

/**
 * Bad Request
 */
export type N400DoResponse = ApiErrorV2;

/**
 * Service Unavailable
 */
export type N503v2Response = ApiErrorV2;

/**
 * Internal Server Error
 */
export type N500v2Response = ApiErrorV2;

/**
 * Not Found
 */
export type N404v2Response = ApiErrorV2;

/**
 * Forbidden
 */
export type N403v2Response = ApiErrorV2;

/**
 * Unauthorized
 */
export type N401v2Response = ApiErrorV2;

/**
 * Bad Request
 */
export type N400v2Response = ApiErrorV2;

/**
 * Service Unavailable
 */
export type N503Response = ApiError;

/**
 * Internal Server Error
 */
export type N500Response = ApiError;

/**
 * Service Unavailable
 */
export type N404Response = ApiError;

/**
 * Forbidden
 */
export type N403Response = ApiError;

/**
 * Unauthorized
 */
export type N401Response = ApiError;

/**
 * Bad Request
 */
export type N400Response = ApiError;

export type WebhookCallbackEventResourceType = typeof WebhookCallbackEventResourceType[keyof typeof WebhookCallbackEventResourceType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WebhookCallbackEventResourceType = {
  TRANSACTIONS: 'TRANSACTIONS',
  CLIENTS: 'CLIENTS',
  PARTIES: 'PARTIES',
  REMITTANCE: 'REMITTANCE',
  ACCOUNTS: 'ACCOUNTS',
} as const;

export type WebhookCallbackEventResourceObject = TransactionCallbackEvent | ClientCallbackEvent | PartyCallbackEvent | RemittanceCallbackEvent | AccountCallbackEvent;

export type WebhookCallbackEventEventType = typeof WebhookCallbackEventEventType[keyof typeof WebhookCallbackEventEventType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WebhookCallbackEventEventType = {
  TRANSACTION_COMPLETED: 'TRANSACTION_COMPLETED',
  TRANSACTION_FAILED: 'TRANSACTION_FAILED',
  CLIENT_ONBOARDING: 'CLIENT_ONBOARDING',
  PARTY_NETWORK_SCREENING: 'PARTY_NETWORK_SCREENING',
  REMITTANCE_STATUS: 'REMITTANCE_STATUS',
  ACCOUNT_CREATED: 'ACCOUNT_CREATED',
  ACCOUNT_CLOSED: 'ACCOUNT_CLOSED',
} as const;

export interface WebhookCallbackEvent {
  error?: ApiErrorV2;
  /** Unique identifier of the event */
  eventId: string;
  eventType: WebhookCallbackEventEventType;
  /** Json formatted string containing the notification details */
  resource: string;
  resourceObject?: WebhookCallbackEventResourceObject;
  resourceType: WebhookCallbackEventResourceType;
}

/**
 * Category of the account
 */
export type AccountCallbackEventType = typeof AccountCallbackEventType[keyof typeof AccountCallbackEventType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountCallbackEventType = {
  CLIENT_DDA: 'CLIENT_DDA',
  DDA: 'DDA',
  LIMITED_DDA: 'LIMITED_DDA',
  EMBEDDED_DDA: 'EMBEDDED_DDA',
  MANAGEMENT: 'MANAGEMENT',
  PROCESSING: 'PROCESSING',
} as const;

/**
 * Account state
 */
export type AccountCallbackEventState = typeof AccountCallbackEventState[keyof typeof AccountCallbackEventState];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountCallbackEventState = {
  OPEN: 'OPEN',
  PENDING_CLOSE: 'PENDING_CLOSE',
  CLOSED: 'CLOSED',
} as const;

export interface AccountCallbackEvent {
  /** A client's unique ID */
  clientId?: string;
  /** The date and time the account was created */
  createdAt?: string;
  /** Account identifier */
  id?: string;
  /** Account label */
  label?: string;
  paymentRoutingInformation?: PaymentRoutingInformation;
  /** Account state */
  state?: AccountCallbackEventState;
  /** Category of the account */
  type?: AccountCallbackEventType;
}

export type PaymentRoutingInformationRoutingInformation = {
  type: RoutingCode;
  /** Routing number */
  value: string;
};

export interface PaymentRoutingInformation {
  country?: SchemasCountryCode;
  /** Account number (PRN) */
  paymentRoutingNumber?: string;
  routingInformation?: PaymentRoutingInformationRoutingInformation;
}

export type RemittanceCallbackEventStatusType = typeof RemittanceCallbackEventStatusType[keyof typeof RemittanceCallbackEventStatusType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RemittanceCallbackEventStatusType = {
  INITIAL_STATUS: 'INITIAL_STATUS',
  TRANSACTION_STATUS_REPORT: 'TRANSACTION_STATUS_REPORT',
} as const;

/**
 * transaction status.
COMPLETED: Good To Pay
COMPLETED: Good To Withdraw
PENDING: Under Review
REJECTED: Cannot Be Processed
ROLLOVER: Rollover To Future Date
RETURNED: Returned
 */
export type StatusDetailsStatus = typeof StatusDetailsStatus[keyof typeof StatusDetailsStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StatusDetailsStatus = {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  REJECTED: 'REJECTED',
  ROLLOVER: 'ROLLOVER',
  RETURNED: 'RETURNED',
} as const;

export type StatusDetailsContextItem = {
  code?: string;
  /** additional information */
  message?: string;
};

/**
 * StatusDetails
 */
export interface StatusDetails {
  /**
   * reasons
   * @minItems 0
   * @maxItems 100
   */
  context?: StatusDetailsContextItem[];
  /** payment information Id */
  paymentId?: string;
  /** record number transaction array index */
  recordNumber?: string;
  /** organization end to end  id */
  remittanceId?: string;
  /** transaction status.
COMPLETED: Good To Pay
COMPLETED: Good To Withdraw
PENDING: Under Review
REJECTED: Cannot Be Processed
ROLLOVER: Rollover To Future Date
RETURNED: Returned */
  status?: StatusDetailsStatus;
}

export interface RemittanceCallbackEvent {
  /** @minItems 1 */
  remittanceStatus?: StatusDetails[];
  statusType?: RemittanceCallbackEventStatusType;
  /** L0 response id */
  traceId?: string;
  /** to identify the transaction flow type */
  transactionType?: string;
  tsrGeneratedDateTime?: string;
}

/**
 * The client's status.
 */
export type PartyCallbackEventProfileStatus = typeof PartyCallbackEventProfileStatus[keyof typeof PartyCallbackEventProfileStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PartyCallbackEventProfileStatus = {
  APPROVED: 'APPROVED',
  DECLINED: 'DECLINED',
  INFORMATION_REQUESTED: 'INFORMATION_REQUESTED',
  NEW: 'NEW',
  REVIEW_IN_PROGRESS: 'REVIEW_IN_PROGRESS',
  SUSPENDED: 'SUSPENDED',
  TERMINATED: 'TERMINATED',
} as const;

export interface PartyCallbackEvent {
  /** Acquirer's External Merchant Id */
  acquirerMerchantId?: string;
  /** A party's unique ID */
  id?: string;
  /** The client's status. */
  profileStatus?: PartyCallbackEventProfileStatus;
}

/**
 * The client's status.
 */
export type ClientCallbackEventStatus = typeof ClientCallbackEventStatus[keyof typeof ClientCallbackEventStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ClientCallbackEventStatus = {
  APPROVED: 'APPROVED',
  DECLINED: 'DECLINED',
  INFORMATION_REQUESTED: 'INFORMATION_REQUESTED',
  NEW: 'NEW',
  REVIEW_IN_PROGRESS: 'REVIEW_IN_PROGRESS',
  SUSPENDED: 'SUSPENDED',
  TERMINATED: 'TERMINATED',
} as const;

export interface ClientCallbackEvent {
  /** `true` if the client has outstanding items, otherwise `false`. */
  hasOutstandingInformation?: boolean;
  /** A client's unique ID */
  id?: string;
  /** The client's status. */
  status?: ClientCallbackEventStatus;
}

export interface TransactionCallbackEvent {
  /**
   * Transaction amount
   */
  amount?: string;
  /** The c2 client id */
  clientId?: string;
  /** The account id of the transaction receiver */
  creditorAccountId?: string;
  /** Payment currency */
  currency?: string;
  /** The account Id of the transaction originator, this could be of type (VTA - Virtual Account) or (DDA - Physical Account) */
  debtorAccountId?: string;
  /** The id of the transaction */
  id?: string;
  /** In case of RETURN transaction, this field has information about the original transaction. For other transactions it has the Memorandum. */
  memo?: string;
  /** ID to show the connection between this transaction and its originating transaction. */
  originatingId?: string;
  /** In case of RETURN transaction, this field refers to the original 'ACH' transaction, for which a RETURN has been initiated. */
  originatingTransactionType?: string;
  /** ISO date format - yyyy-MM-dd */
  paymentDate?: string;
  /** Recipient Id of the transaction receiver */
  recipientId?: string;
  /** The final status of the transaction */
  status?: string;
  /** Transaction reference id provided by client */
  transactionReferenceId?: string;
  /** The type of transaction network such as ACH, RTP, etc ... */
  type?: string;
}

export interface SchemasRoutingInformationDto {
  type: RoutingCode;
  /** Routing number */
  value: string;
}

export interface SchemasPaymentRoutingInformationDtoWithStatus {
  /** Account number (PRN) */
  accountNumber: string;
  country: SchemasCountryCode;
  /**
   * Routing information
   * @minItems 0
   */
  routingInformation?: SchemasRoutingInformationDto[];
  status: PaymentRoutingStatus;
}

export interface SchemasAccountResponseWithStatus {
  category: AccountCategory;
  /** Client identifier */
  clientId?: string;
  /** Closure Reason */
  closureReason?: string;
  /** The date and time the account was created. For the client first account created during onboarding, this is close to the date and time that the client passes onboarding checks. For all other accounts, the timestamp is generated within a few seconds of the new account being requested. */
  createdAt: string;
  /** Account identifier */
  id: string;
  /** Account label */
  label: string;
  paymentRoutingInformation?: SchemasPaymentRoutingInformationDtoWithStatus;
  state: AccountState;
}

export interface SchemasPaymentRoutingInformationDto {
  /** Account number (PRN) */
  accountNumber: string;
  country: SchemasCountryCode;
  /**
   * Routing information
   * @minItems 0
   */
  routingInformation?: SchemasRoutingInformationDto[];
}

export interface SchemasAccountResponse {
  category: AccountCategory;
  /** Client identifier */
  clientId?: string;
  /** The date and time the account was created. For the client first account created during onboarding, this is close to the date and time that the client passes onboarding checks. For all other accounts, the timestamp is generated within a few seconds of the new account being requested. */
  createdAt: string;
  /** Account identifier */
  id: string;
  /** Account label */
  label: string;
  paymentRoutingInformation?: SchemasPaymentRoutingInformationDto;
  state: AccountState;
}

export interface SchemasListAccountsResponse {
  /**
   * List of accounts for a specific client
   * @minItems 0
   */
  items: SchemasAccountResponse[];
  metadata: PageMetaData;
}

/**
 * Routing codes supported (currently only ABA is supported)
 */
export type RoutingCode = typeof RoutingCode[keyof typeof RoutingCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RoutingCode = {
  ABA: 'ABA',
} as const;

export type RoleResponse = SchemasRole & {
  /** @minItems 0 */
  resourceTypes?: string[];
};

export interface ListRoleResponse {
  /**
   * @minItems 0
   * @maxItems 5
   */
  items?: RoleResponse[];
  metadata?: PageMetaData;
}

export type SchemasAction = typeof SchemasAction[keyof typeof SchemasAction];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SchemasAction = {
  ADD: 'ADD',
  REMOVE: 'REMOVE',
} as const;

export interface RoleRequest {
  action?: SchemasAction;
  /**
   * Defines the role type i.e DEBIT_CARD_HOLDER, AUTH_USER
   * @pattern ^[a-zA-Z_]+$
   */
  id: string;
  /**
   * The ID corresponding to the resource.
   * @pattern ^.*$
   */
  resourceId?: string;
  /**
   * Defines the actual resource for a debit card holder, the resource would be the DEBIT_CARD_NO.
   * @pattern ^.*$
   */
  resourceType?: string;
}

export type SchemasCreateUserRequest = User & {
  /**
   * The client ID of the user.
   * @pattern ^\d{10}$
   */
  clientId?: string;
  /** The client party id to link the user to. This is applicable when the party already exists for a C2.
 */
  relatedPartyId?: string;
  /**
   * @minItems 0
   * @maxItems 5
   */
  roles?: RoleRequest[];
};

export interface SchemasApiErrorReason {
  /**
   * Part of the request which is responsible for the reason
   * @minLength 1
   * @maxLength 256
   * @pattern ^.*$
   */
  field?: string;
  /**
   * Message describing the reason. This message can typically be displayed to your platform's users, except in cases specified otherwise
   * @minLength 1
   * @maxLength 512
   * @pattern ^.*$
   */
  message: string;
  /**
   * Readable reason returned to indicate a reason behind the error occurred
   * @minLength 1
   * @maxLength 256
   * @pattern ^[A-Z0-9_]+$
   */
  reason: string;
  /**
   * Rejected value from the request which is responsible for the reason
   * @minLength 1
   * @maxLength 256
   * @pattern ^.*$
   */
  rejectedValue?: string;
}

export interface SchemasApiError {
  /**
   * Readable code returned to indicate an error occurred
   * @minLength 1
   * @maxLength 99
   * @pattern ^[A-Z0-9_]+$
   */
  error: string;
  /**
   * Message describing the error. This message can typically be displayed to your platform's users, except in cases specified otherwise
   * @minLength 1
   * @maxLength 512
   * @pattern ^.*$
   */
  message: string;
  /** @minItems 0 */
  reasons?: SchemasApiErrorReason[];
  /**
   * Trace Id
   * @minLength 1
   * @maxLength 512
   * @pattern ^.*$
   */
  traceId?: string;
}

export interface ListUserResponse {
  /**
   * @minItems 0
   * @maxItems 25
   */
  items?: SchemasUserResponse[];
  metadata?: PageMetaData;
}

export interface SchemasRole {
  /**
   * A brief description for the role.
   * @minLength 1
   * @maxLength 256
   * @pattern ^.*$
   */
  description?: string;
  /** @pattern ^[a-zA-Z_]+$ */
  id: string;
  /**
   * A friendly name for the role.
   * @minLength 1
   * @maxLength 32
   * @pattern ^.*$
   */
  label?: string;
}

export type UserRoleResponse = SchemasRole & {
  /**
   * The ID of the resource
   * @pattern ^.*$
   */
  resourceId?: string;
  /**
   * The type of resource on which the entitlement should be associated
   * @pattern ^.*$
   */
  resourceType?: string;
};

/**
 * Processing status during user/resource creation/update.
 */
export type ProcessingStatus = typeof ProcessingStatus[keyof typeof ProcessingStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProcessingStatus = {
  Setup_In_Progress: 'Setup In Progress',
  Setup_Complete: 'Setup Complete',
  Setup_Failed: 'Setup Failed',
  Update_In_Progress: 'Update In Progress',
  Update_Complete: 'Update Complete',
  Update_Failed: 'Update Failed',
} as const;

/**
 * Status of the user derived from the identity provider.
 */
export type SchemasStatus = typeof SchemasStatus[keyof typeof SchemasStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SchemasStatus = {
  INVITED: 'INVITED',
  ACTIVE: 'ACTIVE',
  LOCKED: 'LOCKED',
  NOT_AVAILABLE: 'NOT_AVAILABLE',
  REMOVED: 'REMOVED',
} as const;

export type SchemasUserResponse = User & {
  /** @pattern ^\d{10}$ */
  clientId?: string;
  /**
   * @minLength 1
   * @maxLength 36
   * @pattern ^[a-zA-Z0-9-]+$
   */
  id?: string;
  processingStatus?: ProcessingStatus;
  /** The client party id to link the user to. This is applicable when the party already exists for a C2.
 */
  relatedPartyId?: string;
  /**
   * @minItems 0
   * @maxItems 5
   */
  roles?: UserRoleResponse[];
  status?: SchemasStatus;
};

/**
 * Type of address e.g. 'Primary Residence' | 'Principal place of business'.
 */
export type AddressType = typeof AddressType[keyof typeof AddressType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AddressType = {
  Principal_place_of_business: 'Principal place of business',
  Local_office: 'Local office',
  Primary_Residence: 'Primary Residence',
  Business_street_address: 'Business street address',
} as const;

export interface SchemasAddress {
  /**
   * addressLine1 must not be a PO Box and must begin with a number.addressLine1 has a maximum of 60 characters.
   * @maxLength 34
   * @pattern (?=.*\d)(?=.*[A-Za-z])^\d.*$|^[NSEWnsew]\d.*$
   */
  addressLine1: string;
  /**
   * addressLine2 has a maximum of 60 characters.
   * @maxLength 34
   * @pattern [\p{L}\p{M}\p{N}\p{P}\p{Z}\p{Cf}\p{Cs}\s]*
   */
  addressLine2?: string;
  /**
   * addressLine3 has a maximum of 60 characters.
   * @maxLength 34
   * @pattern [\p{L}\p{M}\p{N}\p{P}\p{Z}\p{Cf}\p{Cs}\s]*
   */
  addressLine3?: string;
  addressType?: AddressType;
  /**
   * city has a maximum of 30 characters.
   * @maxLength 34
   * @pattern [\p{L}\p{M}\p{N}\p{P}\p{Z}\p{Cf}\p{Cs}\s]*
   */
  city: string;
  /** Country code in alpha-2 format. */
  countryCode: string;
  /**
   * Postal/ZIP code.
   * @maxLength 10
   * @pattern ^[\\p{IsLatin}0-9- \\.]+$
   */
  postalCode: string;
  /**
   * State code in alpha-2 format.
   * @maxLength 30
   * @pattern ^[a-z-A-Z ]+$
   */
  state: string;
}

/**
 * Phone Number Information of the user

 */
export interface SchemasPhone {
  /**
   * The ISO calling code for the phone number.
   * @minLength 1
   * @maxLength 10
   * @pattern ^((\+\d{1,3})|(\d{1,4}))$
   */
  countryCode: string;
  /**
   * @minLength 4
   * @maxLength 15
   * @pattern ^\d{1,15}$
   */
  phoneNumber: string;
}

export interface User {
  address?: SchemasAddress;
  /**
   * Email of the user
   * @minLength 7
   * @maxLength 50
   */
  emailAddress?: string;
  /**
   * First name of the individual in case of party type being an individual like Owners, Controllers and Decision Makers.

   * @minLength 2
   * @maxLength 30
   * @pattern ^(?![-.',])(?!.*[-.',]{2})(?!.*[-.',]$)[a-zA-Z-.', ]*$
   */
  firstName?: string;
  /**
   * Last name of the individual in case of party type being an  individual like Owners, Controllers and Decision Makers.

   * @minLength 2
   * @maxLength 30
   * @pattern ^(?![-.',])(?!.*[-.',]{2})(?!.*[-.',]$)[a-zA-Z-.', ]*$
   */
  lastName?: string;
  /**
   * Middle name of the individual in case of party type being an individual.

   * @minLength 1
   * @maxLength 30
   * @pattern ^(?![-.',])(?!.*[-.',]{2})(?!.*[-.',]$)[a-zA-Z-.', ]*$
   */
  middleName?: string;
  phone?: SchemasPhone;
  /**
   * Username of the user. If not provided during user creation, system will use emailAddress as username. If provided, then it
 - Can be 5 to 30 characters long.
 - Can allow special characters underscore or dot or @
 - Can neither start nor end with any special characters
 - Cannot contain consecutive special characters

   * @minLength 5
   * @maxLength 30
   * @pattern ^(?=.{6,30}$)(?![_.@])(?!.*[_.@]{2})[a-zA-Z0-9._@]+(?<![_.@])$
   */
  username?: string;
}

export type SchemasUpdateUserRequest = User & {
  /**
   * @minItems 0
   * @maxItems 5
   */
  roles?: RoleRequest[];
};

export type FetchLevel = typeof FetchLevel[keyof typeof FetchLevel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FetchLevel = {
  USER_STATUS: 'USER_STATUS',
  PARTY: 'PARTY',
  ROLES: 'ROLES',
} as const;

export interface SchemasStatement {
  /** Statement identifier used to retrieve statement document (Base64 encoded). */
  id?: string;
  metaData?: MetaData;
}

export interface ListDocumentsResponse {
  /**
   * @minItems 0
   * @maxItems 100
   */
  documentDetails?: SchemasDocumentResponse[];
  metadata?: PageMetaDataSmbdo;
}

export type DocumentMetadataKeyEnum = typeof DocumentMetadataKeyEnum[keyof typeof DocumentMetadataKeyEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DocumentMetadataKeyEnum = {
  DOCUMENT_REQUEST_ID: 'DOCUMENT_REQUEST_ID',
  PARTY_ID: 'PARTY_ID',
  FILE_EXTENSION: 'FILE_EXTENSION',
  COUNTRY: 'COUNTRY',
  STATUS: 'STATUS',
  UPLOAD_TIME: 'UPLOAD_TIME',
  UPLOADED_FILE_NAME: 'UPLOADED_FILE_NAME',
} as const;

export interface DocumentMetadataSmbdo {
  key?: DocumentMetadataKeyEnum;
  value?: string;
}

/**
 * Supported document types
 */
export type SchemasDocumentTypeSmbdo = typeof SchemasDocumentTypeSmbdo[keyof typeof SchemasDocumentTypeSmbdo];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SchemasDocumentTypeSmbdo = {
  TERMS_CONDITIONS: 'TERMS_CONDITIONS',
  DISCLOSURE_AND_CONSENT: 'DISCLOSURE_AND_CONSENT',
  JPMC_DISCLOSURE: 'JPMC_DISCLOSURE',
  PASSPORT: 'PASSPORT',
  EIN: 'EIN',
  SSN_CARD: 'SSN_CARD',
  GOV_ISSUED_ID_CARD: 'GOV_ISSUED_ID_CARD',
  STANDARD_OPERATING_PROCEDURE: 'STANDARD_OPERATING_PROCEDURE',
  BRAND_LOGO: 'BRAND_LOGO',
  SUPPORT_CONTACT: 'SUPPORT_CONTACT',
  LEGAL_DOCUMENTS: 'LEGAL_DOCUMENTS',
  EVIDENCE: 'EVIDENCE',
  BULK_PARTY: 'BULK_PARTY',
  DRIVERS_LICENSE: 'DRIVERS_LICENSE',
  IRS_DOCUMENT_TIN: 'IRS_DOCUMENT_TIN',
  ARTICLES_OF_INCORPORATION: 'ARTICLES_OF_INCORPORATION',
  MOA: 'MOA',
  MAA: 'MAA',
  CONSTITUTIONAL_DOCUMENT: 'CONSTITUTIONAL_DOCUMENT',
  TRUST_DEED: 'TRUST_DEED',
  PARTNERSHIP_AGREEMENT: 'PARTNERSHIP_AGREEMENT',
  LLC_AGREEMENT: 'LLC_AGREEMENT',
  OPERATING_AGREEMENT: 'OPERATING_AGREEMENT',
  OFFERING_MEMO: 'OFFERING_MEMO',
  BANKING_LICENSE: 'BANKING_LICENSE',
  BUSINESS_LICENSE: 'BUSINESS_LICENSE',
  BUSINESS_REGISTRATION_CERT: 'BUSINESS_REGISTRATION_CERT',
  OTHER_GOV_REGISTRATION_DOCS: 'OTHER_GOV_REGISTRATION_DOCS',
  SEC_FILINGS_10K: 'SEC_FILINGS_10K',
} as const;

export interface DocumentUploadDataSmbdo {
  documentType: SchemasDocumentTypeSmbdo;
  /**
   * @minItems 0
   * @maxItems 50
   */
  metadata: DocumentMetadataSmbdo[];
}

export interface SchemasDocumentResponse {
  documentType: SchemasDocumentTypeSmbdo;
  id: string;
  /**
   * @minItems 0
   * @maxItems 50
   */
  metadata: DocumentMetadataSmbdo[];
}

/**
 * Number of days from the day of its creation that this request will expire.
 * @minimum 1
 * @maximum 180
 */
export type ValidForDays = number;

export type DocumentRequestStatus = typeof DocumentRequestStatus[keyof typeof DocumentRequestStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DocumentRequestStatus = {
  ACTIVE: 'ACTIVE',
  CLOSED: 'CLOSED',
  EXPIRED: 'EXPIRED',
} as const;

export interface DocumentRequestResponse {
  clientId?: ClientId;
  country?: CountryCodeSmbdo;
  createdAt?: string;
  documentType?: DocumentTypeSmbdo;
  id?: DocumentRequestId;
  partyId?: PartyId;
  /**
   * Any one requirement must be fulfilled.
   * @minItems 1
   * @maxItems 10
   */
  requirements?: DocumentRequestRequirement[];
  status?: DocumentRequestStatus;
  updatedAt?: string;
  validForDays?: ValidForDays;
}

export interface DocumentRequestListResponse {
  /**
   * @minItems 0
   * @maxItems 100
   */
  documentRequests: DocumentRequestResponse[];
  metadata: PageMetaDataSmbdo;
}

export type DocumentRequestRequirementLevel = typeof DocumentRequestRequirementLevel[keyof typeof DocumentRequestRequirementLevel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DocumentRequestRequirementLevel = {
  PRIMARY: 'PRIMARY',
  SECONDARY: 'SECONDARY',
} as const;

export interface DocumentRequestRequirement {
  /**
   * @minItems 1
   * @maxItems 100
   */
  documentTypes: DocumentTypeSmbdo[];
  level?: DocumentRequestRequirementLevel;
  /**
   * @minimum 1
   * @maximum 10
   */
  minRequired?: number;
}

/**
 * Unique Document Request identifier.
 * @maxLength 10
 */
export type DocumentRequestId = string;

export type DocumentTypeSmbdo = typeof DocumentTypeSmbdo[keyof typeof DocumentTypeSmbdo];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DocumentTypeSmbdo = {
  TERMS_CONDITIONS: 'TERMS_CONDITIONS',
  DISCLOSURE_AND_CONSENT: 'DISCLOSURE_AND_CONSENT',
  JPMC_DISCLOSURE: 'JPMC_DISCLOSURE',
  PASSPORT: 'PASSPORT',
  EIN: 'EIN',
  SSN_CARD: 'SSN_CARD',
  GOV_ISSUED_ID_CARD: 'GOV_ISSUED_ID_CARD',
  STANDARD_OPERATING_PROCEDURE: 'STANDARD_OPERATING_PROCEDURE',
  BRAND_LOGO: 'BRAND_LOGO',
  SUPPORT_CONTACT: 'SUPPORT_CONTACT',
  LEGAL_DOCUMENTS: 'LEGAL_DOCUMENTS',
  EVIDENCE: 'EVIDENCE',
  BULK_PARTY: 'BULK_PARTY',
  DRIVERS_LICENSE: 'DRIVERS_LICENSE',
  IRS_DOCUMENT_TIN: 'IRS_DOCUMENT_TIN',
  ARTICLES_OF_INCORPORATION: 'ARTICLES_OF_INCORPORATION',
  MOA: 'MOA',
  MAA: 'MAA',
  CONSTITUTIONAL_DOCUMENT: 'CONSTITUTIONAL_DOCUMENT',
  TRUST_DEED: 'TRUST_DEED',
  PARTNERSHIP_AGREEMENT: 'PARTNERSHIP_AGREEMENT',
  LLC_AGREEMENT: 'LLC_AGREEMENT',
  OPERATING_AGREEMENT: 'OPERATING_AGREEMENT',
  OFFERING_MEMO: 'OFFERING_MEMO',
  BANKING_LICENSE: 'BANKING_LICENSE',
  BUSINESS_LICENSE: 'BUSINESS_LICENSE',
  BUSINESS_REGISTRATION_CERT: 'BUSINESS_REGISTRATION_CERT',
  OTHER_GOV_REGISTRATION_DOCS: 'OTHER_GOV_REGISTRATION_DOCS',
  SEC_FILINGS_10K: 'SEC_FILINGS_10K',
} as const;

/**
 * Country code in ISO alpha-2 format.
 * @minLength 2
 * @maxLength 2
 */
export type CountryCodeSmbdo = string;

export interface QuestionListResponse {
  metadata?: PageMetaDataSmbdo;
  /**
   * @minItems 0
   * @maxItems 100
   */
  questions?: SchemasQuestionResponse[];
}

/**
 * Describes the answer value that would require dependent questions.
 * @maxLength 255
 */
export type AnyValuesMatch = string;

export type SchemasQuestionResponseSubQuestionsItem = {
  anyValuesMatch?: AnyValuesMatch;
  questionIds?: SchemasQuestionIdList;
};

export type ResponseSchemaType = typeof ResponseSchemaType[keyof typeof ResponseSchemaType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResponseSchemaType = {
  array: 'array',
} as const;

export type ResponseSchemaItemType = typeof ResponseSchemaItemType[keyof typeof ResponseSchemaItemType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResponseSchemaItemType = {
  boolean: 'boolean',
  string: 'string',
  number: 'number',
  integer: 'integer',
} as const;

/**
 * Only applicable to string, number, and integer.
 */
export type ResponseSchemaItemFormat = typeof ResponseSchemaItemFormat[keyof typeof ResponseSchemaItemFormat];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResponseSchemaItemFormat = {
  float: 'float',
  double: 'double',
  int32: 'int32',
  int64: 'int64',
  date: 'date',
} as const;

/**
 * A limited subset of JSON Schema used to validate the response value items.
 */
export interface ResponseSchemaItem {
  exclusiveMaximum?: boolean;
  exclusiveMinimum?: boolean;
  /** Only applicable to string, number, and integer. */
  format?: ResponseSchemaItemFormat;
  maximum?: number;
  maxLength?: number;
  minimum?: number;
  minLength?: number;
  /** Only applicable to string. */
  pattern?: string;
  type?: ResponseSchemaItemType;
}

/**
 * A subset of JSON Schema used to validate the response values.
 */
export interface ResponseSchema {
  items?: ResponseSchemaItem;
  maxItems?: number;
  minItems?: number;
  type?: ResponseSchemaType;
}

/**
 * The ID uniquely identifying a question.
 * @maxLength 10
 */
export type QuestionId = string;

/**
 * A list of question IDs.
 * @minItems 1
 * @maxItems 100
 */
export type SchemasQuestionIdList = QuestionId[];

/**
 * A description of the question.
 */
export type QuestionDescription = string;

/**
 * The identifier for a language and location.
 */
export type LocaleId = string;

/**
 * Content displayed to a user for a given locale.
 */
export interface ContentItem {
  description?: string;
  /** Exact text to be displayed to a user. */
  label: string;
  locale: LocaleId;
}

export interface SchemasQuestionResponse {
  /**
   * @minItems 1
   * @maxItems 50
   */
  content?: ContentItem[];
  defaultLocale?: LocaleId;
  description?: QuestionDescription;
  id?: QuestionId;
  parentQuestionId?: QuestionId;
  responseSchema?: ResponseSchema;
  /** @minItems 0 */
  subQuestions?: SchemasQuestionResponseSubQuestionsItem[];
}

export interface UpdatePartyRequest {
  access?: AccessList;
  email?: Email;
  externalId?: ExternalId;
  individualDetails?: IndividualDetails;
  organizationDetails?: OrganizationDetails;
  /**
   * @minItems 1
   * @maxItems 10
   */
  roles?: Role[];
  status?: PartyStatus;
}

export interface CreatePartyRequest {
  access?: AccessList;
  email?: Email;
  externalId?: ExternalId;
  individualDetails?: IndividualDetailsRequired;
  organizationDetails?: OrganizationDetailsRequired;
  parentExternalId?: ExternalId;
  parentPartyId?: ParentPartyId;
  partyType: PartyTypeSmbdo;
  /**
   * @minItems 1
   * @maxItems 10
   */
  roles: Role[];
}

/**
 * The name of the party. A party can be an individual or an organization.
 * @minLength 1
 * @maxLength 500
 */
export type Name = string;

export interface PartySummaryResponse {
  country?: CountryCodeIsoAlpha2;
  createdAt?: string;
  externalId?: ExternalId;
  id?: PartyId;
  name?: Name;
  parentPartyId?: ParentPartyId;
  partyType?: PartyTypeSmbdo;
  profileStatus?: ProfileStatus;
  /**
   * @minItems 0
   * @maxItems 10
   */
  roles?: Role[];
  status?: PartyStatus;
}

export interface PartyListResponse {
  metadata?: PageMetaDataSmbdo;
  /**
   * @minItems 0
   * @maxItems 100
   */
  parties?: PartySummaryResponse[];
}

/**
 * Describes which attestation to remove. An existing attestation with a matching `documentId` will be removed.
 */
export interface AttestationRemoval {
  documentId: DocumentId;
}

/**
 * Update a party inline within the clients API by supplying its ID.
 */
export interface UpdatePartyRequestInline {
  access?: AccessList;
  email?: Email;
  id?: PartyId;
  individualDetails?: IndividualDetails;
  organizationDetails?: OrganizationDetails;
  /**
   * @minItems 1
   * @maxItems 10
   */
  roles?: Role[];
}

export type UpdateClientRequestSmbdoAddPartiesItem = CreatePartyRequestInline & UpdatePartyRequestInline;

export interface UpdateClientRequestSmbdo {
  /**
   * @minItems 1
   * @maxItems 10
   */
  addAttestations?: Attestation[];
  /**
   * Update a party by specifying its ID in the object. Create a party by setting `parentPartyId` to the client's root party. `partyType` and `roles` are required when creating a new party.

   * @minLength 1
   * @maxLength 10
   * @minItems 0
   */
  addParties?: UpdateClientRequestSmbdoAddPartiesItem[];
  addProducts?: ProductList;
  /**
   * @minItems 0
   * @maxItems 200
   */
  questionResponses?: QuestionResponse[];
  /**
   * @minItems 1
   * @maxItems 10
   */
  removeAttestations?: AttestationRemoval[];
}

export type ClientResponseOutstanding = {
  attestationDocumentIds?: DocumentIdList;
  documentRequestIds?: DocumentRequestIdList;
  partyIds?: PartyIdList;
  partyRoles?: PartyRoleList;
  questionIds?: QuestionIdList;
};

export interface ClientResponse {
  /**
   * @minItems 0
   * @maxItems 10
   */
  attestations?: Attestation[];
  id: ClientId;
  outstanding: ClientResponseOutstanding;
  /** @minItems 0 */
  parties?: PartyResponse[];
  partyId: PartyId;
  products: ProductList;
  /**
   * @minItems 0
   * @maxItems 200
   */
  questionResponses?: QuestionResponse[];
  status: ClientStatus;
}

/**
 * The values of a question response. Each item is a string that will be validated according to the question's responseSchema.

 * @minItems 1
 * @maxItems 20
 */
export type ResponseValueList = string[];

/**
 * The client's response to a question.
 */
export interface QuestionResponse {
  /** @maxLength 10 */
  questionId?: string;
  values?: ResponseValueList;
}

export type ValidationResponseItem = {
  /** Comments/basic response related to the workflow step of validation response. */
  comments?: string;
  /**
   * @minItems 0
   * @maxItems 10
   */
  documentRequestIds?: string[];
  /**
   * @minItems 0
   * @maxItems 100
   */
  fields?: PartyField[];
  /**
   * @minItems 0
   * @maxItems 10
   */
  identities?: string[];
  validationStatus?: ValidationStatus;
  validationType?: ValidationType;
};

/**
 * List of validation info.
 * @minItems 0
 * @maxItems 10
 */
export type ValidationResponse = ValidationResponseItem[];

/**
 * A party field. It refers to either a missing field or a field that needs to be updated.
 */
export interface PartyField {
  /** Display name of the field. */
  displayName?: string;
  /** Name of the field. */
  name?: string;
  /** Type of the field. */
  type?: string;
}

export type ValidationType = typeof ValidationType[keyof typeof ValidationType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ValidationType = {
  ENTITY_VALIDATION: 'ENTITY_VALIDATION',
} as const;

/**
 * Status of a party validation. Missing fields result in `NEEDS_INFO`.

 */
export type ValidationStatus = typeof ValidationStatus[keyof typeof ValidationStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ValidationStatus = {
  NOT_STARTED: 'NOT_STARTED',
  IN_PROGRESS: 'IN_PROGRESS',
  NOT_VALIDATED: 'NOT_VALIDATED',
  NEEDS_INFO: 'NEEDS_INFO',
  NEEDS_REVIEW: 'NEEDS_REVIEW',
  VALIDATED: 'VALIDATED',
} as const;

export type PartyStatus = typeof PartyStatus[keyof typeof PartyStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PartyStatus = {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
} as const;

export type ProfileStatus = typeof ProfileStatus[keyof typeof ProfileStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProfileStatus = {
  NEW: 'NEW',
  REVIEW_IN_PROGRESS: 'REVIEW_IN_PROGRESS',
  INFORMATION_REQUESTED: 'INFORMATION_REQUESTED',
  APPROVED: 'APPROVED',
  DECLINED: 'DECLINED',
  SUSPENDED: 'SUSPENDED',
  TERMINATED: 'TERMINATED',
} as const;

export interface CreateClientRequestSmbdo {
  /**
   * @minItems 1
   * @maxItems 10
   */
  attestations?: Attestation[];
  /**
   * @minItems 1
   * @maxItems 10
   */
  parties?: CreatePartyRequestInlineRequired[];
  partyId?: PartyId;
  products: ProductList;
}

export type OrganizationDetailsRequired = OrganizationDetails;

/**
 * Create a party within the clients payload.
 */
export interface CreatePartyRequestInline {
  access?: AccessList;
  email?: Email;
  externalId?: ExternalId;
  individualDetails?: IndividualDetailsRequired;
  organizationDetails?: OrganizationDetailsRequired;
  parentPartyId?: ParentPartyId;
  partyType?: PartyTypeSmbdo;
  /**
   * @minItems 1
   * @maxItems 10
   */
  roles?: Role[];
}

/**
 * Create a party within the clients payload.
 */
export type CreatePartyRequestInlineRequired = CreatePartyRequestInline;

/**
 * Year of company formation.
 * @minLength 4
 * @maxLength 4
 * @pattern \d{4}
 */
export type YearOfFormation = string;

/**
 * Whether the party has a website. False if opted out.
 */
export type WebsiteAvailable = boolean;

/**
 * Name/URL of the website
 * @minLength 1
 * @maxLength 500
 */
export type Website = string;

export type TradeOverInternet = boolean;

/**
 * Significant ownership means there individuals who own 25% or more of the client's business. Always required for a Privately Owned Business. If Significant Ownership is selected as `true`, at least one related party should have the role of owner.

 */
export type SignificantOwnership = boolean;

/**
 * The ID type
 */
export type OrganizationIdentityDtoIdType = typeof OrganizationIdentityDtoIdType[keyof typeof OrganizationIdentityDtoIdType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrganizationIdentityDtoIdType = {
  EIN: 'EIN',
  BUSINESS_REGISTRATION_ID: 'BUSINESS_REGISTRATION_ID',
} as const;

/**
 * The tax ID of the organization.
 */
export interface OrganizationIdentityDto {
  /** Description of the ID. */
  description?: string;
  expiryDate?: string;
  /** The ID type */
  idType: OrganizationIdentityDtoIdType;
  /**
   * Issuing authority
   * @minLength 1
   * @maxLength 500
   */
  issuer: string;
  /**
   * ID value
   * @minLength 1
   * @maxLength 100
   */
  value: string;
}

export type OrganizationType = typeof OrganizationType[keyof typeof OrganizationType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrganizationType = {
  LIMITED_LIABILITY_COMPANY: 'LIMITED_LIABILITY_COMPANY',
  C_CORPORATION: 'C_CORPORATION',
  S_CORPORATION: 'S_CORPORATION',
  PARTNERSHIP: 'PARTNERSHIP',
  PUBLICLY_TRADED_COMPANY: 'PUBLICLY_TRADED_COMPANY',
  NON_PROFIT_CORPORATION: 'NON_PROFIT_CORPORATION',
  GOVERNMENT_ENTITY: 'GOVERNMENT_ENTITY',
  SOLE_PROPRIETORSHIP: 'SOLE_PROPRIETORSHIP',
  UNINCORPORATED_ASSOCIATION: 'UNINCORPORATED_ASSOCIATION',
} as const;

/**
 * The organization‚Äôs description.

 */
export type OrganizationDescription = string;

/**
 * The organization‚Äôs legal name. It is the official name of the person or entity that owns a company. Must be the name used on the legal party's government forms and business paperwork

 */
export type OrganizationName = string;

/**
 * The industry type of the business connected to the client. You can use the Reference Data resource to get a list of acceptable values.

 */
export type OrganizationIndustryType = string;

/**
 * The industry category of the business connected to the client. For example, Accommodation and Food Services. You can use the Reference Data resource to get a list of acceptable values.

 */
export type OrganizationIndustryCategory = string;

/**
 * Entities in ownership means that one or more businesses own part of the business connected to the client. Always required for a Privately Owned Business.

 */
export type EntitiesInOwnership = boolean;

/**
 * @minLength 1
 * @maxLength 100
 */
export type DbaName = string;

export interface OrganizationDetails {
  /**
   * @minItems 1
   * @maxItems 5
   */
  addresses?: AddressDtoSmbdo[];
  /**
   * @minItems 0
   * @maxItems 100
   */
  associatedCountries?: CountryCodeIsoAlpha2[];
  countryOfFormation?: CountryCodeIsoAlpha2;
  dbaName?: DbaName;
  entitiesInOwnership?: EntitiesInOwnership;
  industryCategory?: OrganizationIndustryCategory;
  industryType?: OrganizationIndustryType;
  jurisdiction?: CountryCodeIsoAlpha2;
  organizationDescription?: OrganizationDescription;
  /**
   * @minItems 0
   * @maxItems 6
   */
  organizationIds?: OrganizationIdentityDto[];
  organizationName?: OrganizationName;
  organizationType?: OrganizationType;
  phone?: PhoneSmbdo;
  significantOwnership?: SignificantOwnership;
  tradeOverInternet?: TradeOverInternet;
  website?: Website;
  websiteAvailable?: WebsiteAvailable;
  yearOfFormation?: YearOfFormation;
}

export type IndividualDetailsRequired = IndividualDetails;

export type SoleOwner = boolean;

/**
 * Nature of ownership e.g. Direct|Indirect

 */
export type NatureOfOwnership = string;

export type PhoneSmbdoPhoneType = typeof PhoneSmbdoPhoneType[keyof typeof PhoneSmbdoPhoneType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PhoneSmbdoPhoneType = {
  BUSINESS_PHONE: 'BUSINESS_PHONE',
  MOBILE_PHONE: 'MOBILE_PHONE',
  ALTERNATE_PHONE: 'ALTERNATE_PHONE',
} as const;

/**
 * Phone Number Information of the account

 */
export interface PhoneSmbdo {
  countryCode: string;
  phoneNumber: string;
  phoneType: PhoneSmbdoPhoneType;
}

/**
 * If `jobTitle` is Other, then job title description is required.

 * @maxLength 50
 */
export type IndividualJobTitleDescription = string;

/**
 * Job title in the case of party type being an `INDIVIDUAL`. Job title is a required field for Controllers. Also, If Privately Owned Business is selected as the business type, Job Title should be a required field for Decision Makers. e.g. CEO|CFO|COO|President|Chairman|Senior Branch Manager|Other

 */
export type IndividualJobTitle = string;

/**
 * `idType` denotes the type of taxpayer identification number (e.g. Social Security Number or Individual Taxpayer Identification Number). A Social Security Number or Individual Taxpayer Identification Number is accepted for an owner or controller individual. Decision makers do not require any tax identifier.

 */
export type IndividualIdentityDTOIdType = typeof IndividualIdentityDTOIdType[keyof typeof IndividualIdentityDTOIdType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IndividualIdentityDTOIdType = {
  SSN: 'SSN',
  ITIN: 'ITIN',
} as const;

export interface IndividualIdentityDTO {
  /** Description of the ID. */
  description?: string;
  expiryDate?: string;
  /** `idType` denotes the type of taxpayer identification number (e.g. Social Security Number or Individual Taxpayer Identification Number). A Social Security Number or Individual Taxpayer Identification Number is accepted for an owner or controller individual. Decision makers do not require any tax identifier.
 */
  idType: IndividualIdentityDTOIdType;
  /** Identification issuer country code e.g. US */
  issuer: string;
  /**
   * Value of the identification type. EIN/SSN/ITIN must be of 9 digits.
   * @minLength 1
   * @maxLength 20
   */
  value: string;
}

/**
 * The name suffix used by the party
 * @minLength 1
 * @maxLength 5
 */
export type NameSuffix = string;

/**
 * Last name of the individual in case of party type being an individual like Owners, Controllers and Decision Makers.

 * @minLength 2
 * @maxLength 30
 */
export type LastName = string;

/**
 * Middle name of the individual in case of party type being an individual.

 * @maxLength 30
 */
export type MiddleName = string;

/**
 * First name of the individual in case of party type being an individual like Owners, Controllers and Decision Makers.

 * @minLength 2
 * @maxLength 30
 */
export type FirstName = string;

/**
 * Country code in ISO alpha-2 format.
 * @minLength 2
 * @maxLength 2
 */
export type CountryCodeIsoAlpha2 = string;

/**
 * The date of birth (yyyy-MM-dd) of the individual in case of party type being an individual. This field is not required for the party type Organization.

 */
export type BirthDate = string;

export interface IndividualDetails {
  /**
   * @minItems 1
   * @maxItems 5
   */
  addresses?: AddressDtoSmbdo[];
  birthDate?: BirthDate;
  countryOfResidence?: CountryCodeIsoAlpha2;
  firstName?: FirstName;
  /**
   * @minItems 0
   * @maxItems 16
   */
  individualIds?: IndividualIdentityDTO[];
  jobTitle?: IndividualJobTitle;
  jobTitleDescription?: IndividualJobTitleDescription;
  lastName?: LastName;
  middleName?: MiddleName;
  nameSuffix?: NameSuffix;
  natureOfOwnership?: NatureOfOwnership;
  phone?: PhoneSmbdo;
  soleOwner?: SoleOwner;
}

export interface PartyResponse {
  access?: AccessList;
  createdAt?: string;
  email?: Email;
  externalId?: ExternalId;
  id?: PartyId;
  individualDetails?: IndividualDetails;
  organizationDetails?: OrganizationDetails;
  parentExternalId?: ExternalId;
  parentPartyId?: ParentPartyId;
  partyType?: PartyTypeSmbdo;
  profileStatus?: ProfileStatus;
  /**
   * @minItems 0
   * @maxItems 10
   */
  roles?: Role[];
  status?: PartyStatus;
  validationResponse?: ValidationResponse;
}

/**
 * Type of address.
 */
export type AddressDtoSmbdoAddressType = typeof AddressDtoSmbdoAddressType[keyof typeof AddressDtoSmbdoAddressType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AddressDtoSmbdoAddressType = {
  LEGAL_ADDRESS: 'LEGAL_ADDRESS',
  MAILING_ADDRESS: 'MAILING_ADDRESS',
  BUSINESS_ADDRESS: 'BUSINESS_ADDRESS',
  RESIDENTIAL_ADDRESS: 'RESIDENTIAL_ADDRESS',
} as const;

export interface AddressDtoSmbdo {
  /**
   * The first line must not be a PO Box and must begin with a number. Each line has a maximum of 60 characters.
   * @minItems 1
   * @maxItems 5
   */
  addressLines: string[];
  /** Type of address. */
  addressType?: AddressDtoSmbdoAddressType;
  /**
   * city has a maximum of 30 characters.
   * @maxLength 34
   */
  city: string;
  /** Country code in alpha-2 format. */
  country: string;
  /**
   * Postal/ZIP code.
   * @maxLength 10
   */
  postalCode: string;
  /**
   * State code in alpha-2 format. State is mandatory for countries like United States.
   * @maxLength 30
   */
  state?: string;
}

export type Role = typeof Role[keyof typeof Role];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Role = {
  AUTHORIZED_USER: 'AUTHORIZED_USER',
  BENEFICIAL_OWNER: 'BENEFICIAL_OWNER',
  CLIENT: 'CLIENT',
  CONTROLLER: 'CONTROLLER',
  DECISION_MAKER: 'DECISION_MAKER',
  PRIMARY_CONTACT: 'PRIMARY_CONTACT',
} as const;

/**
 * The party type
 */
export type PartyTypeSmbdo = typeof PartyTypeSmbdo[keyof typeof PartyTypeSmbdo];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PartyTypeSmbdo = {
  INDIVIDUAL: 'INDIVIDUAL',
  ORGANIZATION: 'ORGANIZATION',
} as const;

/**
 * The Parent Party Id.

 * @maxLength 10
 */
export type ParentPartyId = string;

/**
 * Id in external system.
 * @minLength 1
 * @maxLength 20
 */
export type ExternalId = string;

/**
 * Email of the party.
 */
export type Email = string;

/**
 * List of user access descriptors.
 * @minItems 0
 * @maxItems 10
 */
export type AccessList = string[];

/**
 * The client's status.
 */
export type ClientStatus = typeof ClientStatus[keyof typeof ClientStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ClientStatus = {
  APPROVED: 'APPROVED',
  DECLINED: 'DECLINED',
  INFORMATION_REQUESTED: 'INFORMATION_REQUESTED',
  NEW: 'NEW',
  REVIEW_IN_PROGRESS: 'REVIEW_IN_PROGRESS',
  SUSPENDED: 'SUSPENDED',
  TERMINATED: 'TERMINATED',
} as const;

export interface ClientSummaryResponse {
  id: ClientId;
  outstanding: ClientSummaryResponseOutstanding;
  partyId: PartyId;
  products: ProductList;
  status: ClientStatus;
}

/**
 * Collection of clients.
 */
export interface ClientListResponse {
  /**
   * @minItems 0
   * @maxItems 100
   */
  clients: ClientSummaryResponse[];
  metadata: PageMetaDataSmbdo;
}

export type PartyRoleListItem = typeof PartyRoleListItem[keyof typeof PartyRoleListItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PartyRoleListItem = {
  AUTHORIZED_USER: 'AUTHORIZED_USER',
  BENEFICIAL_OWNER: 'BENEFICIAL_OWNER',
  CLIENT: 'CLIENT',
  CONTROLLER: 'CONTROLLER',
  DECISION_MAKER: 'DECISION_MAKER',
  PRIMARY_CONTACT: 'PRIMARY_CONTACT',
} as const;

/**
 * A list of party roles.
 * @minItems 0
 * @maxItems 10
 */
export type PartyRoleList = PartyRoleListItem[];

/**
 * A list of party IDs.
 * @minItems 0
 * @maxItems 10
 */
export type PartyIdList = PartyId[];

/**
 * A list of question IDs.
 * @minItems 0
 * @maxItems 200
 */
export type QuestionIdList = string[];

/**
 * A list of document request IDs.
 * @minItems 0
 * @maxItems 10
 */
export type DocumentRequestIdList = string[];

/**
 * The unique id generated by the system for the uploaded document,  which can be used for future retrieval.

 */
export type DocumentId = string;

export interface Attestation {
  attestationTime?: string;
  /** The full name of an individual. */
  attesterFullName?: string;
  documentId?: DocumentId;
  /** IPv4 Address. */
  ipAddress?: string;
}

/**
 * A list of document IDs.
 * @minItems 0
 * @maxItems 10
 */
export type DocumentIdList = DocumentId[];

export type ClientSummaryResponseOutstanding = {
  attestationDocumentIds?: DocumentIdList;
  documentRequestIds?: DocumentRequestIdList;
  partyIds?: PartyIdList;
  partyRoles?: PartyRoleList;
  questionIds?: QuestionIdList;
};

/**
 * A product available for a client in a jurisdiction.
 */
export type ClientProduct = string;

/**
 * A list of product selections.
 * @minItems 1
 * @maxItems 50
 */
export type ProductList = ClientProduct[];

/**
 * Organization/Individual party id, that uniquely identifies the party.

 * @maxLength 10
 */
export type PartyId = string;

/**
 * A client's unique ID
 * @maxLength 10
 */
export type ClientId = string;

export interface PageMetaDataSmbdo {
  /** Number of records per page.
 */
  limit?: number;
  /** Page Number.
 */
  page?: number;
  /** Total number of items.
 */
  total?: number;
}

/**
 * Two letter country code based on ISO 3166 standard (currently only US is supported)
 */
export type SchemasCountryCode = typeof SchemasCountryCode[keyof typeof SchemasCountryCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SchemasCountryCode = {
  US: 'US',
} as const;

/**
 * First line of the recipient's postal address.
For payment types ACH, WIRE and RTP routingCodeType, routingNumber and countryCode are required.
For payment type of ACH account type is required.

 */
export interface SchemasTransactionRecipientAccount {
  countryCode?: SchemasCountryCode;
  number: AccountNumber;
  routingCodeType?: RoutingCodeType;
  routingNumber?: RoutingNumber;
  type?: AccountType;
}

/**
 * Address details for the recipient. Mandatory for payments using the RTP payment type.
 */
export interface SchemasRecipientAddress {
  /**
   * addressLine1 must not be a PO Box and must begin with a number.addressLine1 has a maximum of 60 characters.
   * @maxLength 34
   */
  addressLine1: string;
  /**
   * addressLine2 has a maximum of 60 characters.
   * @maxLength 34
   */
  addressLine2?: string;
  /**
   * addressLine3 has a maximum of 60 characters.
   * @maxLength 34
   */
  addressLine3?: string;
  /** Type of address e.g. 'Primary Residence' | 'Principal place of business'. */
  addressType?: string;
  /**
   * city has a maximum of 30 characters.
   * @maxLength 34
   */
  city: string;
  countryCode: SchemasCountryCode;
  /**
   * Postal/ZIP code.
   * @maxLength 10
   */
  postalCode: string;
  /**
   * State code in alpha-2 format. State is mandatory for countries like United States.
   * @maxLength 30
   */
  state?: string;
}

export interface SchemasRecipientPartyDetails {
  address?: SchemasRecipientAddress;
  /**
   * Recipient company name. Mandatory for recipient type ORGANIZATION.

   * @maxLength 140
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  businessName?: string;
  /**
   * Contact details for the recipient.
   * @minItems 0
   */
  contacts?: RecipientContact[];
  /**
   * Recipient's first name. Mandatory for recipient type INDIVIDUAL.

   * @maxLength 70
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  firstName?: string;
  /**
   * Recipient's last name. Mandatory for recipient type INDIVIDUAL.

   * @maxLength 70
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  lastName?: string;
  type: PartyType;
}

export interface ApiErrorV2 {
  /**
   * Provides additional context and detail on the validation errors
   * @minItems 0
   * @maxItems 100
   */
  context?: ApiErrorReasonV2[];
  /** HTTP status code */
  httpStatus: number;
  /** Client provided request identifier */
  requestId?: string;
  /** Short humanly-readable title of the error */
  title: string;
  /** Internal assigned traced identifier */
  traceId?: string;
}

/**
 * If the status is present in the response, CIP has been performed
 */
export type CustomerIdentificationResponseCustomerIdentificationStatus = typeof CustomerIdentificationResponseCustomerIdentificationStatus[keyof typeof CustomerIdentificationResponseCustomerIdentificationStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CustomerIdentificationResponseCustomerIdentificationStatus = {
  CIP_PASSED: 'CIP_PASSED',
  CIP_FAILED: 'CIP_FAILED',
  CIP_PENDING_VERIFICATION: 'CIP_PENDING_VERIFICATION',
} as const;

export interface CustomerIdentificationResponse {
  /** If the status is present in the response, CIP has been performed */
  customerIdentificationStatus: CustomerIdentificationResponseCustomerIdentificationStatus;
}

export interface AttestationRequest {
  /** Unique identifier of the legal document that must be attested by the user. For example, terms & conditions or disclosure & consent documents. */
  documentId: string;
  /**  First and last name of the attester. */
  fullName: string;
  /**  Attested IP address */
  ipAddress: string;
}

export type AttestationsRequest = AttestationRequest;

export interface ClientVerificationsInformationRequest {
  /** @minItems 0 */
  attestations?: AttestationsRequest[];
  /** @minItems 0 */
  verifications?: VerificationsRequest[];
}

export interface AnswerRequest {
  /**
   * The answer/s of a question. Can contain one or more elements. In case where response options are provided, it has to be the id/s depending on single or list format. In case of other formats e.g. freeText, there can be only one element.

   * @minItems 0
   * @maxItems 100
   */
  values: string[];
}

export interface VerificationIdRequest {
  /** The unique identifier for a personal identification verification. */
  id: string;
}

export interface VerificationRequest {
  response: AnswerRequest;
  verification: VerificationIdRequest;
}

export type VerificationsRequest = VerificationRequest;

export interface AdditionalDocument {
  /** Unique identifier of the document which user uploaded */
  documentId?: string;
  /** Identity documents level - The category of document which is predefined. Primary is one of the categories and has some limited set of applicable documents. */
  documentLevel?: string;
  /** Specifies type of the document uploaded */
  documentType?: string;
  /** Specifies number of days remaining to upload documents  */
  numberOfDaysRemainingToUpload?: string;
  /** Related Party id */
  partyId?: string;
  /** Specifies the party type, for Legal Entity it is Organization and for Related party e.g. Owner/Controller etc. it is Individual */
  partyType?: string;
  /** Status of the document. REQUESTED means the document needs to be provided */
  status?: string;
  /**
   * @minItems 0
   * @maxItems 100
   */
  supportedDocuments?: string[];
}

export type AdditionalDocuments = AdditionalDocument;

export interface ClientVerificationsInformationResponse {
  /** @minItems 0 */
  additionalDocuments?: AdditionalDocuments[];
  /** @minItems 0 */
  attestations?: AttestationsResponse[];
  /** If the status is present in the response, verifications are submitted for the client */
  status?: string;
  /** @minItems 0 */
  verifications?: VerificationsResponse[];
}

export interface AttestationResponse {
  /** date time of submission in ISO format yyyy-MM-ddTHH:mm:ss */
  attestationDateTime?: string;
  /** Unique identifier of the legal document that must be attested by the user. For example, terms & conditions or disclosure & consent documents. */
  documentId?: string;
  /** Name of the document */
  documentName?: string;
  /** The type of document. Can be terms and conditions or disclosure and consent documents. */
  documentType?: string;
  /** Document version */
  documentVersion?: string;
  /**  First and last name of the attester. */
  fullName?: string;
  /**  Attested IP address */
  ipAddress?: string;
}

export type AttestationsResponse = AttestationResponse;

export interface AnswerOption {
  /** Internal id value, not to be shared with user */
  id?: string;
  /** External readable value to be presented to the user. */
  label?: string;
}

export interface AnswerResponse {
  /** @minItems 0 */
  answerOptions?: AnswerOption[];
  /** Can be single for one item in the values or list in case of more than one values. The other options are word, freeText, alphaNumeric and there will be only one element allowed */
  format?: string;
  /** max length allowed in values field. In case of freeText, the maximum length is 2000 */
  maxLength?: number;
  /** Id of parent Question */
  parentId?: string;
  /** date time of submission in ISO format yyyy-MM-ddTHH:mm:ss */
  updatedDateTime?: string;
  /**
   * The answer/s of a question. Can contain one or more elements.

   * @minItems 0
   */
  values?: string[];
}

export interface VerificationIdResponse {
  /** The unique identifier for a personal identification verification. */
  id?: string;
  /** verification question. */
  label?: string;
}

export interface VerificationResponse {
  response?: AnswerResponse;
  verification?: VerificationIdResponse;
}

export type VerificationsResponse = VerificationResponse;

export type UpdateRelatedPartiesResponseAllOf = {
  /** Client id, that uniquely identifies the client.
 */
  id: string;
};

export type UpdateRelatedPartiesResponse = UpdateRelatedPartyRequest & UpdateRelatedPartiesResponseAllOf;

export type UpdateClientResponseAllOf = {
  /**
   * The products available for clients.

   * @minItems 0
   */
  products?: string[];
  /** @minItems 0 */
  relatedParties?: UpdateRelatedPartiesResponse[];
};

export type UpdateClientResponse = UpdateEntityDetailBusinessRequest & UpdateClientResponseAllOf;

export type UpdateRelatedPartiesRequestAllOf = {
  /** The action like ADD, UPDATE, REMOVE
 */
  action: string;
};

export type UpdateRelatedPartiesRequest = UpdateRelatedPartyRequest & UpdateRelatedPartiesRequestAllOf;

export type UpdateClientRequestAllOf = {
  /** @minItems 0 */
  relatedParties?: UpdateRelatedPartiesRequest[];
};

export type UpdateClientRequest = UpdateEntityDetailBusinessRequest & UpdateClientRequestAllOf;

export type UpdateRelatedPartyRequestAllOf = {
  /** The date of birth (yyyy-MM-dd) of the individual in case of party type being an individual. This field is not required for the party type Organization.
 */
  birthDate?: string;
  /** The business‚Äôs legal name. It is the official name of the person or entity that owns a company. And, it‚Äôs the name used on your government forms and business paperwork. This field is only required when party type is NON-IND
 */
  businessName?: string;
  /** Email of the individual.
 */
  email?: string;
  /**
   * First name of the individual in case of party type being an individual like Owners, Controllers and Decision Makers.

   * @minLength 2
   * @maxLength 30
   */
  firstName?: string;
  /** Unique identifier for this party. It is only required for UPDATE and REMOVE actions
 */
  id?: string;
  /** Job title in case of party type being an individual. JobTitle is required field for Controllers. Also, If Privately Owned Business is selected as the business type, Job Title should be a required field for Decision Makers. e.g. CEO|CFO|COO|President|Chairman|Senior Branch Manager|Other
 */
  jobTitle?: string;
  /**
   * In case on jobTitle is Other then Job title description is required.This field can be set to empty by passing field value as ("") in request.

   * @maxLength 50
   */
  jobTitleDescription?: string;
  /**
   * Last name of the individual in case of party type being an individual like Owners, Controllers and Decision Makers.

   * @minLength 2
   * @maxLength 30
   */
  lastName?: string;
  /**
   * Middle name of the individual in case of party type being an individual.This field can be set to empty by passing field value as ("") in request.

   * @maxLength 30
   */
  middleName?: string;
  /** Nature of ownership e.g. Direct|Indirect.This field can be set to empty by passing field value as ("") in request.
 */
  natureOfOwnership?: string;
  /**
   * A Party role which could have one or more of the following values: CLIENT, CONTROLLER, MARKETPLACE_OPERATOR, OWNER, PAYEE, DECISION_MAKER
If a SMB controller and owner is the same person - you have to send two parties with the distinct partyRoles e.g. [ CLIENT, CONTROLLER, MARKETPLACE_OPERATOR, OWNER, DECISION_MAKER ]

   * @minItems 0
   * @maxItems 100
   */
  partyRole?: string[];
  /** A Party type which could have one of the following distinct values: Organization, Individual, NonIndividual
 */
  partyType?: string;
  soleOwner?: boolean;
};

export type UpdateRelatedPartyRequest = UpdatePartyDetailCommon & UpdateRelatedPartyRequestAllOf;

export type UpdateEntityDetailBusinessRequestAllOf = {
  /** Client id, that uniquely identifies the client.
 */
  id?: string;
};

export type UpdatePartyDetailBusinessAllOf = {
  /** The business‚Äôs alias name. It is the other alias name of the  entity that owns a company.This field can be set to empty by passing field value as ("") in request.
 */
  businessAliasName?: string;
  /** The business‚Äôs description.
 */
  businessDescription?: string;
  /** The business‚Äôs legal name. It is the official name of the person or entity that owns a company.
And, it‚Äôs the name used on your government forms and business paperwork
 */
  businessName?: string;
  /** The different business entity types that can be selected e.g. Privately Owned Business | Sole Proprietorship
 */
  businessType?: string;
  /** Country code in alpha-2 format */
  countryOfFormation?: string;
  /**
   * Email of the client.

   * @maxLength 50
   */
  email?: string;
  /** If entitiesInOwnership is true, are there any businesses included in your ownership hierarchy? e.g. true|false. entitiesInOwnership is required for Privately Owned Business.
 */
  entitiesInOwnership?: boolean;
  /** Distinct industry category. e.g. - Accommodation and Food Services - Administrative and Support and Waste Management and Remediation Services - Agriculture, Forestry, Fishing and Hunting (not covered in economic census) - Arts, Entertainment, and Recreation - Construction - Educational Services - Finance and Insurance - Health Care and Social Assistance - Individuals - Information - Management of Companies and Enterprises - Manufacturing - Mining, Quarrying, and Oil and Gas Extraction - Other Services (except Public Administration) - Professional, Scientific, and Technical Services - Public Administration (not covered in economic census) - Real Estate and Rental and Leasing - Retail Trade - Transportation and Warehousing - Utilities - Wholesale Trade
 */
  industryCategory?: string;
  /** Industry type.
 */
  industryType?: string;
  /** Legal Structure of the business entity. Legal structure is required for Privately Owned Business and Sole Proprietorship.
 */
  legalStructure?: string;
  /** Are there any individuals who own 25% or more of your business? e.g. true|false. significantOwnership is required for Privately Owned Business. If Significant Ownership is selected as True, At least one related party should have a role of owner.
 */
  significantOwnership?: boolean;
  /** Website of the client. website is required if websiteAvailable is true.This field can be set to empty by passing field value as ("") in request.
 */
  website?: string;
  /** Does your business have a website? e.g. true|false
 */
  websiteAvailable?: boolean;
  /** Year of formation. Max and Min length is 4.
 */
  yearOfFormation?: string;
};

export type UpdatePartyDetailBusiness = UpdatePartyDetailCommon & UpdatePartyDetailBusinessAllOf;

export type UpdateEntityDetailBusinessRequest = UpdatePartyDetailBusiness & UpdateEntityDetailBusinessRequestAllOf;

export interface UpdateIdentityDTO {
  /** The action like ADD, UPDATE, REMOVE
 */
  action: string;
  /** Description of identification type e.g. Social Security Number */
  idDescription?: string;
  /** Identification issuer country name e.g. US */
  idIssuer: string;
  /** IdType denotes the type of taxpayer identification numbers e.g. SSN/EIN. EIN is acceptable idType for Privately Owned Business. Sole Proprietorship can have EIN/SSN as idType. For individuals like Owners and Controllers SSN is accepted as idType.
 */
  idType: string;
  /** Value of the identification type. EIN/SSN must be of 9 digits. */
  idValue: string;
}

/**
 * Phone Number Information of the account

 */
export interface UpdatePhone {
  /**
   * The ISO calling code for the phone number.
   * @minLength 1
   * @maxLength 10
   * @pattern ^((\+\d{1,3})|(\d{1,4}))$
   */
  countryCode?: string;
  /**
   * @minLength 7
   * @maxLength 14
   * @pattern ^\d{7,14}$
   */
  phoneNumber?: string;
}

export interface UpdateAddressDto {
  /**
   * addressLine1 must not be a PO Box and must begin with a number.addressLine1 has a maximum of 60 characters.
   * @maxLength 34
   * @pattern (?=.*\d)(?=.*[A-Za-z])^\d.*$|^[NSEWnsew]\d.*$
   */
  addressLine1: string;
  /**
   * addressLine2 has a maximum of 60 characters.This field can be set to empty by passing field value as ("") in request.
   * @maxLength 34
   * @pattern [\p{L}\p{M}\p{N}\p{P}\p{Z}\p{Cf}\p{Cs}\s]*
   */
  addressLine2?: string;
  /**
   * addressLine3 has a maximum of 60 characters.This field can be set to empty by passing field value as ("") in request.
   * @maxLength 34
   * @pattern [\p{L}\p{M}\p{N}\p{P}\p{Z}\p{Cf}\p{Cs}\s]*
   */
  addressLine3?: string;
  /** Type of address e.g. 'Primary Residence' | 'Principle Place Of Business'. */
  addressType?: string;
  /**
   * city has a maximum of 30 characters.
   * @maxLength 34
   * @pattern [\p{L}\p{M}\p{N}\p{P}\p{Z}\p{Cf}\p{Cs}\s]*
   */
  city: string;
  /** Country code in alpha-2 format. */
  countryCode: string;
  /**
   * Postal/ZIP code.
   * @maxLength 10
   * @pattern ^[\\p{IsLatin}0-9- \\.]+$
   */
  postalCode: string;
  /**
   * State code in alpha-2 format. State is mandatory for countries like United States.
   * @maxLength 2
   * @pattern ^[a-z-A-Z ]+$
   */
  state?: string;
}

export interface UpdatePartyDetailCommon {
  address?: UpdateAddressDto;
  /** @minItems 0 */
  identities?: UpdateIdentityDTO[];
  phone?: UpdatePhone;
}

/**
 * Part of the request which is responsible for the reason
 */
export type ApiErrorReasonV2Location = typeof ApiErrorReasonV2Location[keyof typeof ApiErrorReasonV2Location];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApiErrorReasonV2Location = {
  BODY: 'BODY',
  QUERY: 'QUERY',
  PATH: 'PATH',
  HEADER: 'HEADER',
} as const;

export interface ApiErrorReasonV2 {
  /** Short code that identifies the error - publicly cataloged and documented */
  code?: string;
  /** The location of the property or parameter in error */
  field?: string;
  /** Part of the request which is responsible for the reason */
  location?: ApiErrorReasonV2Location;
  /** Message describing the reason. This message can typically be displayed to your platform's users, except in cases specified otherwise */
  message: string;
}

export interface ApiError {
  /**
   * Provides additional context and detail on the validation errors
   * @minItems 0
   * @maxItems 100
   */
  context?: ApiErrorReasonV2[];
  /** HTTP status code */
  httpStatus: number;
  /** Client provided request identifier */
  requestId?: string;
  /** Short humanly-readable title of the error */
  title: string;
  /** Internal assigned traced identifier */
  traceId?: string;
}

export interface PageMetaData {
  /** Number of records per page.
 */
  limit?: number;
  /** Page Number.
 */
  page?: number;
  /** Total number of items.
 */
  total_items?: number;
}

/**
 * Category of account in create requests
 */
export type AccountCategoryReq = typeof AccountCategoryReq[keyof typeof AccountCategoryReq];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountCategoryReq = {
  LIMITED_DDA: 'LIMITED_DDA',
  EMBEDDED_DDA: 'EMBEDDED_DDA',
} as const;

/**
 * Category of account
 */
export type AccountCategory = typeof AccountCategory[keyof typeof AccountCategory];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountCategory = {
  CLIENT_DDA: 'CLIENT_DDA',
  CLIENT_OFFSET: 'CLIENT_OFFSET',
  DDA: 'DDA',
  EMBEDDED_DDA: 'EMBEDDED_DDA',
  LIMITED_DDA: 'LIMITED_DDA',
  MANAGEMENT: 'MANAGEMENT',
  PROCESSING: 'PROCESSING',
  PROCESSING_OFFSET: 'PROCESSING_OFFSET',
} as const;

/**
 * Account state
 */
export type ModifyAccountRequestState = typeof ModifyAccountRequestState[keyof typeof ModifyAccountRequestState];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModifyAccountRequestState = {
  OPEN: 'OPEN',
  PENDING_CLOSE: 'PENDING_CLOSE',
  CLOSED: 'CLOSED',
} as const;

export interface ModifyAccountRequest {
  /** Account state */
  state?: ModifyAccountRequestState;
}

/**
 * Balance type: ITAV (interim available balance) or ITBD (interim booked balance)
 */
export type AccountBalanceDtoTypeCode = typeof AccountBalanceDtoTypeCode[keyof typeof AccountBalanceDtoTypeCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountBalanceDtoTypeCode = {
  ITAV: 'ITAV',
  ITBD: 'ITBD',
} as const;

export interface AccountBalanceDto {
  /** Balance amount */
  amount: number;
  /** Balance type: ITAV (interim available balance) or ITBD (interim booked balance) */
  typeCode: AccountBalanceDtoTypeCode;
}

export interface AccountBalanceResponse {
  /**
   * List of account balances of type ITAV (interim available balance) or ITBD (interim booked balance)
   * @minItems 0
   */
  balanceTypes: AccountBalanceDto[];
  /** Balance currency */
  currency: string;
  /** Balance date in ISO date format - yyyy-MM-dd */
  date: string;
  /** Account identifier */
  id: string;
}

export interface RoutingInformationDto {
  type: RoutingCode;
  /** Routing number */
  value: string;
}

export interface PaymentRoutingInformationDto {
  /** Account number (PRN) */
  accountNumber: string;
  country: SchemasCountryCode;
  /**
   * Routing information
   * @minItems 0
   */
  routingInformation?: RoutingInformationDto[];
}

/**
 * Payment routing status. Identifies whether the account is active, which means it has been used within the last 13 months. An account with the status INACTIVE is changed to ACTIVE as soon as a transaction is made on the account.
 */
export type PaymentRoutingStatus = typeof PaymentRoutingStatus[keyof typeof PaymentRoutingStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PaymentRoutingStatus = {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
} as const;

export interface PaymentRoutingInformationDtoWithStatus {
  /** Account number (PRN) */
  accountNumber: string;
  country: SchemasCountryCode;
  /**
   * Routing information
   * @minItems 0
   */
  routingInformation?: RoutingInformationDto[];
  status: PaymentRoutingStatus;
}

/**
 * Account State
 */
export type AccountState = typeof AccountState[keyof typeof AccountState];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountState = {
  OPEN: 'OPEN',
  CLOSED: 'CLOSED',
  PENDING_CLOSE: 'PENDING_CLOSE',
} as const;

export interface AccountResponse {
  category: AccountCategory;
  /** Client identifier */
  clientId?: string;
  /** The date and time the account was created. For the client first account created during onboarding, this is close to the date and time that the client passes onboarding checks. For all other accounts, the timestamp is generated within a few seconds of the new account being requested. */
  createdAt: string;
  /** Account identifier */
  id: string;
  /** Account label */
  label: string;
  paymentRoutingInformation?: PaymentRoutingInformationDto;
  state: AccountState;
}

export interface ListAccountsResponse {
  /**
   * List of accounts for a specific client
   * @minItems 0
   */
  items: AccountResponse[];
  metadata: PageMetaData;
}

export interface AccountResponseWithStatus {
  category: AccountCategory;
  /** Client identifier */
  clientId?: string;
  /** Closure Reason */
  closureReason?: string;
  /** The date and time the account was created. For the client first account created during onboarding, this is close to the date and time that the client passes onboarding checks. For all other accounts, the timestamp is generated within a few seconds of the new account being requested. */
  createdAt: string;
  /** Account identifier */
  id: string;
  /** Account label */
  label: string;
  paymentRoutingInformation?: PaymentRoutingInformationDtoWithStatus;
  state: AccountState;
}

export interface CreateAccountRequest {
  category?: AccountCategoryReq;
  /**
   * Client identifier
   * @pattern ^\d{10}$
   */
  clientId?: string;
  /** Account label: MAIN, PROJECT, TAXES or RAINY_DAY */
  label?: string;
}

export interface Address {
  /**
   * addressLine1 must not be a PO Box and must begin with a number.addressLine1 has a maximum of 60 characters.
   * @maxLength 34
   */
  addressLine1: string;
  /**
   * addressLine2 has a maximum of 60 characters.
   * @maxLength 34
   */
  addressLine2?: string;
  /**
   * addressLine3 has a maximum of 60 characters.
   * @maxLength 34
   */
  addressLine3?: string;
  /** Type of address e.g. 'Primary Residence' | 'Principal place of business'. */
  addressType?: string;
  /**
   * city has a maximum of 30 characters.
   * @maxLength 34
   */
  city: string;
  /** Country code in alpha-2 format. */
  countryCode: string;
  /**
   * Postal/ZIP code.
   * @maxLength 10
   */
  postalCode: string;
  /**
   * State code in alpha-2 format. State is mandatory for countries like United States.
   * @maxLength 30
   */
  state?: string;
}

export type UserResponseAllOf = {
  id: string;
  status?: Status;
};

export type UserResponse = CreateUserRequest & UserResponseAllOf;

export interface UsersResponse {
  /**
   * @minItems 0
   * @maxItems 100
   */
  items?: UserResponse[];
  metadata?: PageMetaData;
}

export interface UpdateInternalUserRequest {
  address?: Address;
  /** Unique User ID that was assigned to the user during creation */
  clientId?: string;
  email?: string;
  firstName?: string;
  lastName?: string;
  middleName?: string;
  phone?: Phone;
  status?: Status;
}

export interface CreateUserRequest {
  address?: Address;
  clientId: string;
  emailAddress?: string;
  firstName?: string;
  lastName?: string;
  middleName?: string;
  phone?: Phone;
  /** The client party id to link the user to.
 */
  relatedPartyId?: string;
}

export type Status = typeof Status[keyof typeof Status];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Status = {
  INVITED: 'INVITED',
  REMOVED: 'REMOVED',
  ACTIVE: 'ACTIVE',
  LOCKED: 'LOCKED',
} as const;

export interface UpdateUserRequest {
  address?: Address;
  emailAddress?: string;
  firstName?: string;
  lastName?: string;
  middleName?: string;
  phone?: Phone;
  status?: Status;
}

export interface LegalDocumentExistsResponse {
  documentExists?: boolean;
}

export interface GPPTransaction {
  /** Account Number of the Card Holder. */
  accountNumber?: string;
  /** Authorization code for a hold transaction. */
  authCode?: string;
  /** Amount declined for Authorization. */
  authDeclineAmount?: number;
  /** Date time of the Authorization decline for the transaction. */
  authDeclineDateTime?: string;
  /** Authorization decline number for the transaction. */
  authDeclineNumber?: string;
  /** Decline type of Authorization for the transaction. */
  authDeclineType?: string;
  /**
   * Last 4 digits of the Card Serial Number.
   * @maxLength 4
   */
  cardLast4?: string;
  /** Decline reason. */
  declineReasonDescription?: string;
  /** Dispensed amount for the transaction. */
  dispensedAmount?: number;
  /** Link sequence number used to uniquely identify a transaction. */
  linkSequence?: string;
  /** City of the Merchant where the transaction was made. */
  merchantCity?: string;
  /** Country code of the Merchant where the transaction was made. */
  merchantCountry?: string;
  /** Name of the Merchant where the transaction was made. */
  merchantName?: string;
  /** State code of the Merchant where the transaction was made. */
  merchantState?: string;
  /** Transaction message type. */
  messageType?: string;
  /** Source surcharge amount for the transaction. */
  sourceSurchargeAmount?: number;
  /** Unique Identifier to trace the transaction. */
  traceId?: string;
  /** Transaction Amount. */
  transactionAmount?: string;
  /** GPP transaction code. */
  transactionCode?: string;
  /** Transaction Date time. */
  transactionDateTime?: string;
  /** Status of the transaction. */
  transactionStatus?: string;
  /** Transaction type. */
  transactionType?: string;
}

export type TaskRequestStatus = typeof TaskRequestStatus[keyof typeof TaskRequestStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TaskRequestStatus = {
  PENDING: 'PENDING',
  CANCEL: 'CANCEL',
  IN_REVIEW: 'IN_REVIEW',
  APPROVE: 'APPROVE',
  REJECT: 'REJECT',
} as const;

export type TaskSubType = typeof TaskSubType[keyof typeof TaskSubType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TaskSubType = {
  AGING_BREAK: 'AGING_BREAK',
  ALLOWED_ACCOUNT: 'ALLOWED_ACCOUNT',
  AML: 'AML',
  C1_ACCOUNT: 'C1_ACCOUNT',
  C1_ACCOUNT_STRUCTURE: 'C1_ACCOUNT_STRUCTURE',
  C1_PROFILE: 'C1_PROFILE',
  C2_SHELL_PROFILE: 'C2_SHELL_PROFILE',
  CARD: 'CARD',
  CLIENT_OFFSET: 'CLIENT_OFFSET',
  COAL: 'COAL',
  FDIC: 'FDIC',
  FEE: 'FEE',
  FRAUD: 'FRAUD',
  GENERAL: 'GENERAL',
  JPMC_ACCOUNT: 'JPMC_ACCOUNT',
  MANAGEMENT_ACCOUNT: 'MANAGEMENT_ACCOUNT',
  OFFBOARDING: 'OFFBOARDING',
  OTHER: 'OTHER',
  PROBATE: 'PROBATE',
  PROCESSING_OFFSET: 'PROCESSING_OFFSET',
  PROFILE: 'PROFILE',
  RESTRICTIONS: 'RESTRICTIONS',
  SANCTION: 'SANCTION',
  USERS: 'USERS',
  PAYMENT_INTENT: 'PAYMENT_INTENT',
} as const;

export type TaskType = typeof TaskType[keyof typeof TaskType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TaskType = {
  ACCOUNT_BLOCK_UPDATE: 'ACCOUNT_BLOCK_UPDATE',
  APPLY_FEE: 'APPLY_FEE',
  CANCEL_RESTRICTION: 'CANCEL_RESTRICTION',
  CASCADE_FEE_CONFIGURATION: 'CASCADE_FEE_CONFIGURATION',
  CLEAR_AGING_BREAK: 'CLEAR_AGING_BREAK',
  CLOSE_ACCOUNT: 'CLOSE_ACCOUNT',
  CREATE_ACCOUNT: 'CREATE_ACCOUNT',
  CREATE_AVS_CONFIGURATION: 'CREATE_AVS_CONFIGURATION',
  CREATE_FEE_ACCOUNT: 'CREATE_FEE_ACCOUNT',
  CREATE_FEE_CONFIGURATION: 'CREATE_FEE_CONFIGURATION',
  CREATE_PROFILE: 'CREATE_PROFILE',
  CREATE_PROGRAM: 'CREATE_PROGRAM',
  CREATE_PRN_ALLOCATION: 'CREATE_PRN_ALLOCATION',
  CREATE_RESTRICTION: 'CREATE_RESTRICTION',
  DELETE_FEE_CONFIGURATION: 'DELETE_FEE_CONFIGURATION',
  DELETE_REVENUE_SHARING: 'DELETE_REVENUE_SHARING',
  KYC_COMPLETION_STATUS_UPDATE: 'KYC_COMPLETION_STATUS_UPDATE',
  ONBOARDING_COMPLETE_STATUS_UPDATE: 'ONBOARDING_COMPLETE_STATUS_UPDATE',
  RELEASE_HOLD: 'RELEASE_HOLD',
  REMOVE_RESTRICTION: 'REMOVE_RESTRICTION',
  REVERSE_FEE: 'REVERSE_FEE',
  SETUP_REVENUE_SHARING: 'SETUP_REVENUE_SHARING',
  UPDATE_AVS_CONFIGURATION: 'UPDATE_AVS_CONFIGURATION',
  UPDATE_ENABLE_PAYOUTS: 'UPDATE_ENABLE_PAYOUTS',
  UPDATE_FEE_CONFIGURATION: 'UPDATE_FEE_CONFIGURATION',
  UPDATE_PROFILE: 'UPDATE_PROFILE',
  UPDATE_PROGRAM: 'UPDATE_PROGRAM',
  UPDATE_PRN_ALLOCATION: 'UPDATE_PRN_ALLOCATION',
  UPDATE_REVENUE_SHARING: 'UPDATE_REVENUE_SHARING',
  UPDATE_USER_STATUS: 'UPDATE_USER_STATUS',
  CANCEL_PAYMENT_INTENT: 'CANCEL_PAYMENT_INTENT',
} as const;

export type AvsConfigResponse = any;

export type AvsConfigRequestAllOf = { [key: string]: any };

export type AvsConfigRequest = AvsConfigRequestAllOf;

export interface MetaData {
  /** Payment routing number of the account related to the statement. */
  accountNumber?: string;
  /** Statement creation date and time. */
  createdDate?: string;
  month?: string;
  year?: string;
}

export interface Statement {
  /** Statement identifier used to retrieve statement document (Base64 encoded). */
  id?: string;
  metaData?: MetaData;
}

export interface StatementsResponse {
  /** @minItems 0 */
  statements?: SchemasStatement[];
}

export interface PartyTypesResponse {
  /**
   * The list of available partyRoles e.g.   "Individual", "Organization"
   * @minItems 0
   */
  partyTypes?: string[];
}

export interface NatureOfOwnershipsResponse {
  /**
   * The list of available partyRoles e.g.  "Direct", "Indirect"
   * @minItems 0
   */
  natureOfOwnerships?: string[];
}

export interface AddressTypesResponse {
  /**
   * The list of available partyRoles e.g. "Principle place of business", "Primary Residence"
   * @minItems 0
   */
  addressTypes?: string[];
}

export interface PartyRolesResponse {
  /**
   * The list of available partyRoles e.g. OWNER, DECISION_MAKER, CONTROLLER
   * @minItems 0
   */
  partyRoles?: string[];
}

export interface IdentificationInformation {
  length?: number;
  name?: string;
  type?: string;
}

export interface LegalStructureResponse {
  /**
   * The list of client legal structures
   * @minItems 0
   */
  legalStructures?: string[];
}

/**
 * @minItems 0
 */
export type IndustryCategories = IndustryCategory[];

export interface IndustryCategoriesResponse {
  items?: IndustryCategories;
  metadata?: PageMetaData;
}

export interface CountryInformation {
  /**
   * ISO 3166-1 Alpha-2 Country Code
   * @minLength 2
   * @maxLength 2
   * @pattern ^[A-Z]{2}$
   */
  code?: string;
  name?: string;
}

export interface ProductInformation {
  code?: string;
  name?: string;
}

export interface ProductResponse {
  /** @minItems 0 */
  products?: ProductInformation[];
}

export interface SubdivisionInformation {
  /**
   * @minLength 1
   * @maxLength 3
   * @pattern ^[0-9A-Z]{1,3}$
   */
  code?: string;
  name?: string;
}

export interface StateInformation {
  code?: string;
  name?: string;
}

export interface DocumentTypeItem {
  /**
   * @minLength 1
   * @maxLength 200
   * @pattern ^.*\S.*$
   */
  id?: string;
  /**
   * @minLength 1
   * @maxLength 200
   * @pattern ^.*\S.*$
   */
  label?: string;
  /** @minItems 0 */
  legalStructures?: string[];
}

export type DocumentTypesOrganization = {
  /**
   * @minItems 0
   * @maxItems 25
   */
  primary?: DocumentTypeItem[];
  /**
   * @minItems 0
   * @maxItems 25
   */
  secondary?: DocumentTypeItem[];
};

export type DocumentTypesIndividual = {
  /**
   * @minItems 0
   * @maxItems 25
   */
  primary?: DocumentTypeItem[];
  /**
   * @minItems 0
   * @maxItems 25
   */
  secondary?: DocumentTypeItem[];
};

export interface DocumentTypes {
  category?: string;
  individual?: DocumentTypesIndividual;
  organization?: DocumentTypesOrganization;
}

export interface DocumentTypeResponse {
  /**
   * ISO 3166-1 Alpha-2 Country Code
   * @minLength 2
   * @maxLength 2
   * @pattern ^[A-Z]{2}$
   */
  country?: string;
  documentTypes?: DocumentTypes;
}

/**
 * @minItems 0
 */
export type DocumentTypesResponses = DocumentTypeResponse[];

export interface DocumentTypesResponse {
  items?: DocumentTypesResponses;
  metadata?: PageMetaData;
}

export interface IndustryCategory {
  industryCategory?: string;
  /** @minItems 0 */
  industryTypes?: string[];
}

export interface CountrySubdivision {
  /**
   * ISO 3166-1 Alpha-2 Country Code
   * @minLength 2
   * @maxLength 2
   * @pattern ^[A-Z]{2}$
   */
  countryCode?: string;
  /** @minItems 0 */
  subDivision?: SubdivisionInformation[];
}

/**
 * @minItems 0
 * @maxItems 100
 */
export type CountrySubdivisionArray = CountrySubdivision[];

export interface CountrySubdivisionResponse {
  items?: CountrySubdivisionArray;
  metadata?: PageMetaData;
}

export interface JobTitlesResponse {
  /**
   * The list of job titles
   * @minItems 0
   */
  jobTitles?: string[];
}

export interface BusinessTypesResponse {
  /**
   * The list of business types.
   * @minItems 0
   */
  businessTypes?: string[];
}

export interface CountriesResponse {
  /** @minItems 0 */
  countries?: CountryInformation[];
}

export interface ClientSuffixes {
  /**
   * The list of client suffixes
   * @minItems 0
   */
  suffixes?: string[];
}

export interface IdentificationTypeResponse {
  /** @minItems 0 */
  identificationTypes?: IdentificationInformation[];
}

/**
 * The event types to be notified of.
 */
export type SubscriptionEventType = typeof SubscriptionEventType[keyof typeof SubscriptionEventType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SubscriptionEventType = {
  TRANSACTION_COMPLETED: 'TRANSACTION_COMPLETED',
  TRANSACTION_FAILED: 'TRANSACTION_FAILED',
  CLIENT_ONBOARDING: 'CLIENT_ONBOARDING',
  REMITTANCE_STATUS: 'REMITTANCE_STATUS',
  PARTY_NETWORK_SCREENING: 'PARTY_NETWORK_SCREENING',
  CLIENT_ONBOARDING_COMPLETED: 'CLIENT_ONBOARDING_COMPLETED',
  CLIENT_OFFBOARDING_COMPLETED: 'CLIENT_OFFBOARDING_COMPLETED',
  CLIENT_ADD_INFO_REQUESTED: 'CLIENT_ADD_INFO_REQUESTED',
  CLIENT_ADD_INFO_VERIFIED: 'CLIENT_ADD_INFO_VERIFIED',
  CLIENT_ADD_INFO_FAILED: 'CLIENT_ADD_INFO_FAILED',
  ACCOUNT_CREATED: 'ACCOUNT_CREATED',
  ACCOUNT_CLOSED: 'ACCOUNT_CLOSED',
} as const;

/**
 * The webhooks you are subscribed to. Each subscription contains events about which you are notified via HTTPS request to your pre-configured server URL.
 */
export interface Subscription {
  /** The event types to be notified of. */
  eventType: SubscriptionEventType;
}

/**
 * The status of this webhook.
 */
export type WebhookResponseStatus = typeof WebhookResponseStatus[keyof typeof WebhookResponseStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WebhookResponseStatus = {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
} as const;

export interface WebhookResponse {
  /** The date and time the webhook was created */
  createdAt: string;
  /** The unique identifier of this webhook */
  id: string;
  /** The status of this webhook. */
  status: WebhookResponseStatus;
  /**
   * @minItems 0
   * @maxItems 100
   */
  subscriptions: Subscription[];
  /** The date and time the webhook was updated */
  updatedAt: string;
}

export interface ListWebhookResponse {
  /**
   * List of webhooks you have created.
   * @minItems 0
   * @maxItems 256
   */
  items: WebhookResponse[];
  metadata: PageMetaData;
}

/**
 * Allowed status - ACTIVE or INACTIVE
 */
export type WebhookUpdateRequestStatus = typeof WebhookUpdateRequestStatus[keyof typeof WebhookUpdateRequestStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WebhookUpdateRequestStatus = {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
} as const;

/**
 * Update a webhook - add, remove subscriptions or change the status of your webhook
 */
export interface WebhookUpdateRequest {
  /** Allowed status - ACTIVE or INACTIVE */
  status: WebhookUpdateRequestStatus;
  /** @minItems 0 */
  subscriptions: Subscription[];
}

/**
 * Create a webhook
 */
export interface WebhookRequest {
  /**
   * List of subscription items called subscription details
   * @minItems 0
   * @maxItems 100
   */
  subscriptions: Subscription[];
}

/**
 * The events you are subscribed to.
 */
export type EventResponse = EventRequest & {
  /** The date and time the subscription was created. Returned in the RFC-3339 datetime format. */
  createdAt?: string;
  /** The date and time the subscription was updated. Returned in the RFC-3339 datetime format. */
  updatedAt?: string;
};

/**
 * The status of the subscription of an event.
 */
export type EventRequestStatus = typeof EventRequestStatus[keyof typeof EventRequestStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EventRequestStatus = {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
} as const;

/**
 * The event types to be notified of.
 */
export type EventRequestEventType = typeof EventRequestEventType[keyof typeof EventRequestEventType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EventRequestEventType = {
  CASE_CREATED: 'CASE_CREATED',
  CASE_UPDATED: 'CASE_UPDATED',
  CLIENT_ONBOARDING_COMPLETED: 'CLIENT_ONBOARDING_COMPLETED',
} as const;

/**
 * The events you are subscribed to.
 */
export interface EventRequest {
  /** The event types to be notified of. */
  eventType: EventRequestEventType;
  /** The status of the subscription of an event. */
  status?: EventRequestStatus;
}

export interface SubscriptionsUpdateRequest {
  /** @minItems 1 */
  events: EventRequest[];
}

/**
 * The type of notification to be sent
 */
export type SubscriptionsCreateRequestChannel = typeof SubscriptionsCreateRequestChannel[keyof typeof SubscriptionsCreateRequestChannel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SubscriptionsCreateRequestChannel = {
  EMAIL: 'EMAIL',
} as const;

export interface SubscriptionsCreateRequest {
  /** The type of notification to be sent */
  channel: SubscriptionsCreateRequestChannel;
  /** @minItems 1 */
  events: EventRequest[];
}

/**
 * The format of the notification
 */
export type SubscriptionsResponseChannel = typeof SubscriptionsResponseChannel[keyof typeof SubscriptionsResponseChannel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SubscriptionsResponseChannel = {
  EMAIL: 'EMAIL',
} as const;

export interface SubscriptionsResponse {
  /** The format of the notification */
  channel: SubscriptionsResponseChannel;
  /** The date and time the subscription was created. Returned in the RFC-3339 datetime format. */
  createdAt: string;
  /** @minItems 1 */
  events: EventResponse[];
  /** The unique identifier of this subscription */
  id: string;
  /** The date and time the subscription was updated. Returned in the RFC-3339 datetime format. */
  updatedAt: string;
}

export interface SubscriptionsListResponse {
  /**
   * List of subscriptions.
   * @minItems 0
   */
  items: SubscriptionsResponse[];
  metadata: PageMetaData;
}

export interface Notification {
  content?: string;
  /** Creation timestamp of this notification eg.(yyyy-MM-ddTHH:MM:SSZ) */
  createdAt?: string;
  dedupeId?: string;
  error?: string;
  eventType?: string;
  /** The unique identifier of this notification */
  id?: string;
  maxRetry?: number;
  messageId?: string;
  /** The platform ID of the susbcription related to this notification */
  platformId?: string;
  platformType?: string;
  /** Timestamp of when this notification was published eg.(yyyy-MM-ddTHH:MM:SSZ) */
  publishedAt?: string;
  retryCount?: number;
  source?: string;
  status?: string;
  statusCode?: string;
  statusDescription?: string;
  /** The unique identifier of the subscription details for this notification */
  subscriptionDetailsId?: string;
  /** The unique identifier of the subscription related to this notification */
  subscriptionId?: string;
  target?: string;
}

/**
 * FAQ Type enum
 */
export type FaqType = typeof FaqType[keyof typeof FaqType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FaqType = {
  C1_General: 'C1 General',
  C1_Specific: 'C1 Specific',
} as const;

export interface Faq {
  /** Answer */
  answer: string;
  /** Question */
  question: string;
  /**
   * FAQ Tags
   * @minItems 0
   */
  tags: string[];
  /** FAQ Type enum */
  type: FaqType;
}

/**
 * List of FAQ Questions and Answers
 */
export interface FAQResponse {
  /**
   * Object of a FAQ
   * @minItems 0
   */
  faqs: Faq[];
}

export interface ClearingSystemId {
  /** Routing number */
  id?: string;
  /** Routing code */
  idType?: string;
}

export interface FinancialInstitutionId {
  clearingSystemId?: ClearingSystemId;
}

export interface ProviderResponse {
  /** Microdeposit notification */
  mdNotification?: string;
  retryCount?: number;
}

export interface Details {
  /** Account number */
  accountNumber?: string;
  financialInstitutionId?: FinancialInstitutionId;
  /** Payment Check Contributing Status */
  paymentCheckContributingStatus?: string;
  providerResponse?: ProviderResponse;
}

export interface Result {
  /** Account validation response code */
  code?: number;
  /** Account validation response message, message is based on the code */
  message?: string;
}

export interface Codes {
  authentication?: Result;
  authenticationMicroDeposit?: Result;
  error?: Result;
  verification?: Result;
  verificationMicroDeposit?: Result;
}

export interface Responses {
  codes?: Codes;
  details?: Details;
  /** Name of the entity that provided the validation */
  provider?: string;
}

export interface AccountValidationResponse {
  /** Profile name to identify account validation configuration */
  profileName?: string;
  /** Unique identifier for a set of related requests */
  requestId?: string;
  /**
   * Account validation responses
   * @minItems 0
   */
  responses?: Responses[];
}

/**
 * Two letter country code based on ISO 3166 standard. Only US is supported in this version of Embedded Banking.
 */
export type CountryCode = typeof CountryCode[keyof typeof CountryCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CountryCode = {
  US: 'US',
} as const;

/**
 * Routing number corresponding to the routing code type (currently only USABA compliant routing numbers are supported)
 * @pattern ^\d{9}$
 */
export type RoutingNumber = string;

/**
 * Type of routing code. Only USABA is supported in this version of Embedded Banking.
 */
export type RoutingCodeType = typeof RoutingCodeType[keyof typeof RoutingCodeType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RoutingCodeType = {
  USABA: 'USABA',
} as const;

/**
 * Type of transaction.
 */
export type RoutingInformationTransactionType = typeof RoutingInformationTransactionType[keyof typeof RoutingInformationTransactionType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RoutingInformationTransactionType = {
  ACH: 'ACH',
  RTP: 'RTP',
  WIRE: 'WIRE',
} as const;

export interface RoutingInformation {
  routingCodeType: RoutingCodeType;
  routingNumber: RoutingNumber;
  transactionType: RoutingInformationTransactionType;
}

/**
 * Type of bank account, either CHECKING or SAVINGS. Only required for ACH payments. Exclude field from payload completely if not needed.
 */
export type AccountType = typeof AccountType[keyof typeof AccountType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountType = {
  CHECKING: 'CHECKING',
  SAVINGS: 'SAVINGS',
} as const;

/**
 * Payment Routing Number or Demand Deposit Account number.
 * @pattern ^\d{1,35}$
 */
export type AccountNumber = string;

/**
 * Bank account details of the recipient.
 */
export interface RecipientAccount {
  countryCode: SchemasCountryCode;
  number: AccountNumber;
  /**
   * Routing information.
   * @minItems 1
   * @maxItems 3
   */
  routingInformation?: RoutingInformation[];
  type: AccountType;
}

export type MicrodepositVerificationResponseStatus = typeof MicrodepositVerificationResponseStatus[keyof typeof MicrodepositVerificationResponseStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MicrodepositVerificationResponseStatus = {
  VERIFIED: 'VERIFIED',
  FAILED: 'FAILED',
  FAILED_MAX_ATTEMPTS_EXCEEDED: 'FAILED_MAX_ATTEMPTS_EXCEEDED',
} as const;

/**
 * Microdeposit verification outcome
 */
export interface MicrodepositVerificationResponse {
  status: MicrodepositVerificationResponseStatus;
}

/**
 * Microdeposit amount verification
 */
export interface MicrodepositAmounts {
  /** @minItems 0 */
  amounts: number[];
}

/**
 * Type of contact information being provided
 */
export type RecipientContactContactType = typeof RecipientContactContactType[keyof typeof RecipientContactContactType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RecipientContactContactType = {
  EMAIL: 'EMAIL',
  WEBSITE: 'WEBSITE',
  PHONE: 'PHONE',
} as const;

export interface RecipientContact {
  /**
   * Type of contact information being provided
   */
  contactType: RecipientContactContactType;
  /**
   * E.164 format compatible telephone country code
Mandatory for contactType PHONE

   * @pattern ^\+[1-9]\d{0,2}$
   */
  countryCode?: string;
  /**
   * Contact information corresponding to contactType: 
PHONE - E.164-compliant telephone number (excluding country code).
EMAIL - Email address (addr-spec in Section 3.4 of RFC 5322).
WEBSITE - URL starting with http:// or https://.

   * @minLength 1
   * @maxLength 2048
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  value: string;
}

/**
 * Address details for the recipient. Mandatory for payments using the RTP payment type.
 */
export interface RecipientAddress {
  /**
   * addressLine1 must not be a PO Box and must begin with a number.addressLine1 has a maximum of 60 characters.
   * @maxLength 34
   */
  addressLine1: string;
  /**
   * addressLine2 has a maximum of 60 characters.
   * @maxLength 34
   */
  addressLine2?: string;
  /**
   * addressLine3 has a maximum of 60 characters.
   * @maxLength 34
   */
  addressLine3?: string;
  /** Type of address e.g. 'Primary Residence' | 'Principal place of business'. */
  addressType?: string;
  /**
   * city has a maximum of 30 characters.
   * @maxLength 34
   */
  city: string;
  countryCode: SchemasCountryCode;
  /**
   * Postal/ZIP code.
   * @maxLength 10
   */
  postalCode: string;
  /**
   * State code in alpha-2 format. State is mandatory for countries like United States.
   * @maxLength 30
   */
  state?: string;
}

/**
 */
export type RecipientStatus = typeof RecipientStatus[keyof typeof RecipientStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RecipientStatus = {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  MICRODEPOSITS_INITIATED: 'MICRODEPOSITS_INITIATED',
  READY_FOR_VALIDATION: 'READY_FOR_VALIDATION',
  REJECTED: 'REJECTED',
} as const;

/**
 */
export type RecipientType = typeof RecipientType[keyof typeof RecipientType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RecipientType = {
  RECIPIENT: 'RECIPIENT',
  LINKED_ACCOUNT: 'LINKED_ACCOUNT',
  SETTLEMENT_ACCOUNT: 'SETTLEMENT_ACCOUNT',
} as const;

/**
 */
export type PartyType = typeof PartyType[keyof typeof PartyType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PartyType = {
  INDIVIDUAL: 'INDIVIDUAL',
  ORGANIZATION: 'ORGANIZATION',
} as const;

export interface RecipientPartyDetails {
  address?: RecipientAddress;
  /**
   * Recipient company name. Mandatory for recipient type ORGANIZATION.

   * @maxLength 140
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  businessName?: string;
  /**
   * Contact details for the recipient.
   * @minItems 0
   */
  contacts?: RecipientContact[];
  /**
   * Recipient's first name. Mandatory for recipient type INDIVIDUAL.

   * @maxLength 70
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  firstName?: string;
  /**
   * Recipient's last name. Mandatory for recipient type INDIVIDUAL.

   * @maxLength 70
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  lastName?: string;
  type: PartyType;
}

export interface Recipient {
  account?: RecipientAccount;
  /**
   * Account validation response
   * @minItems 1
   * @maxItems 10
   */
  accountValidationResponse?: AccountValidationResponse[];
  /** Client identifier */
  clientId?: string;
  /** The date and time the recipient was created */
  createdAt?: string;
  id: string;
  partyDetails: RecipientPartyDetails;
  /** Related Party Identifier for Linked Accounts */
  partyId?: string;
  status?: RecipientStatus;
  type?: RecipientType;
  /** The date and time the recipient was last updated */
  updatedAt?: string;
}

export interface UpdateRecipientRequest {
  account?: RecipientAccount;
  partyDetails?: RecipientPartyDetails;
  status?: RecipientStatus;
}

export interface RecipientRequest {
  account?: RecipientAccount;
  /** Client identifier */
  clientId?: string;
  partyDetails?: RecipientPartyDetails;
  /** Related Party Identifier for Linked Accounts */
  partyId?: string;
  type?: RecipientType;
}

export type ListRecipientsResponseAllOf = {
  /**
   * Recipients available in current page
   * @minItems 0
   */
  recipients?: Recipient[];
};

export type ListRecipientsResponse = PageMetaData & ListRecipientsResponseAllOf;

export interface Contact {
  /** @maxLength 15 */
  contactNumber?: string;
  /** @maxLength 5 */
  countryCode?: string;
}

/**
 * Address Object

 */
export interface CardAddress {
  address1?: string;
  address2?: string;
  address3?: string;
  city?: string;
  country?: string;
  postalCode?: string;
  state?: string;
}

export type GovernmentIdIdType = typeof GovernmentIdIdType[keyof typeof GovernmentIdIdType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GovernmentIdIdType = {
  L: 'L',
  P: 'P',
  R: 'R',
  T: 'T',
  U: 'U',
  V: 'V',
  X: 'X',
} as const;

export interface GovernmentId {
  idExpirationDate?: string;
  idIssuanceCountry?: string;
  idIssuanceDate?: string;
  idType?: GovernmentIdIdType;
  idValue?: string;
}

export interface CardDetailsErrorResponse {
  /** Freeform explanatory text for the error.
 */
  errorDescription: string;
  /** A code defined by the service for the external partner that includes a more specific information of what caused the error.
 */
  externalErrorCode?: string;
  /** A code defined by the API provider that describes the specific error for a given API. This code provides more fine grained information than the httpStatusCode. As an example if an API provides an httpStatusCode of 400 they may also include the serviceErrorCode that includes more specific information of what caused a 400 response. (i.e. INVALID_EMAIL, INVALID_PHONE_NUMBER, etc)
 */
  serviceErrorCode?: string;
}

export interface DebitCardsResponse {
  /**
   * List of debit cards for a specific client
   * @minItems 0
   */
  items: DebitCard[];
  metadata: PageMetaData;
}

/**
 * An Object with Card Detail Response for specific Card Id

 */
export interface CardDetailResponse {
  /** Account Identifier/ Payment Routing Number
 */
  accountId: string;
  /** Web link to the Card Holder Profile
 */
  link: string;
}

/**
 * An Object containing Create Debit Card Response

 */
export interface CreateDebitCardResponse {
  /** Account Identifier/ Payment Routing Number
 */
  accountId?: string;
  /** Card Identifier
 */
  id?: string;
  /** Link to the Customer Profile
 */
  link?: string;
  /** Customer Card Information Message
 */
  message?: string;
}

/**
 * An Object containing Create Debit Card Request

 */
export interface CreateDebitCardRequest {
  /** Account Identifier/ Payment Routing Number
 */
  accountId: string;
  /**
   * The total amount of cash that can be withdrawn in a single day. Resets at 00:00 each day.

   * @minimum 0
   */
  maxCashWithdrawalLimit?: number;
  /**
   * The maximum total amount that can be spent in a single day. Resets at 00:00 each day.

   * @minimum 0
   */
  maxSpendLimit?: number;
  /**
   * Party Id of the Card Holder

   */
  relatedPartyId: string;
}

/**
 * An object with response corresponding to the status of the card.
 */
export interface CardUpdateResponse {
  /** New Card Identifier to Update */
  id?: string;
  /** Message for operation status. */
  message?: string;
}

export type CardLimitChangeRequestMaxDailySpend = {
  /** Whether this limit is active/inactive */
  active?: boolean;
  /**
   * The maximum amount that can be spent in a single day. Resets at 00:00 each day.
   * @minimum 0
   */
  value?: number;
};

export type CardLimitChangeRequestMaxDailyCashWithdrawal = {
  /** Whether this limit is active/inactive */
  active?: boolean;
  /**
   * The maximum amount of cash that can be withdrawn in a single day. Resets at 00:00 each day.
   * @minimum 0
   */
  value?: number;
};

/**
 * An object to request a change in card limit(s).
 */
export interface CardLimitChangeRequest {
  maxDailyCashWithdrawal?: CardLimitChangeRequestMaxDailyCashWithdrawal;
  maxDailySpend?: CardLimitChangeRequestMaxDailySpend;
}

/**
 * An object to request a card pin number be changed.
 */
export interface CardPinChangeRequest {
  /** 4 digit ATM pin to be used for associated card. */
  pin?: string;
}

/**
 * Reason for replacing card.
 */
export type CardReplaceRequestReason = typeof CardReplaceRequestReason[keyof typeof CardReplaceRequestReason];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CardReplaceRequestReason = {
  LOST: 'LOST',
  STOLEN: 'STOLEN',
  DAMAGED: 'DAMAGED',
  OTHER: 'OTHER',
} as const;

/**
 * An object to request a card be replaced.
 */
export interface CardReplaceRequest {
  /** Reason for replacing card. */
  reason?: CardReplaceRequestReason;
}

/**
 * Reason for cancelling card.
 */
export type CardCancelRequestReason = typeof CardCancelRequestReason[keyof typeof CardCancelRequestReason];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CardCancelRequestReason = {
  LOST: 'LOST',
  STOLEN: 'STOLEN',
  OTHER: 'OTHER',
} as const;

/**
 * An object to request a card be cancelled.
 */
export interface CardCancelRequest {
  /** Reason for cancelling card. */
  reason?: CardCancelRequestReason;
}

/**
 * New status of the card after request. Can be locked/unlocked/replaced/cancelled status.
Optional field. Only use if you want to update the status of the card.

 */
export type CardUpdateRequestStatus = typeof CardUpdateRequestStatus[keyof typeof CardUpdateRequestStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CardUpdateRequestStatus = {
  LOCKED: 'LOCKED',
  UNLOCKED: 'UNLOCKED',
  REPLACED: 'REPLACED',
  CANCELLED: 'CANCELLED',
} as const;

/**
 * Reason for replacing card. Only required if status is set to REPLACED.

 */
export type CardUpdateRequestReplacementReason = typeof CardUpdateRequestReplacementReason[keyof typeof CardUpdateRequestReplacementReason];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CardUpdateRequestReplacementReason = {
  LOST: 'LOST',
  STOLEN: 'STOLEN',
  DAMAGED: 'DAMAGED',
  DEFECTIVE: 'DEFECTIVE',
} as const;

/**
 * Reason for cancelling card. Only required if status is set to CANCELLED.

 */
export type CardUpdateRequestCancellingReason = typeof CardUpdateRequestCancellingReason[keyof typeof CardUpdateRequestCancellingReason];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CardUpdateRequestCancellingReason = {
  LOST: 'LOST',
  STOLEN: 'STOLEN',
  DEACTIVE: 'DEACTIVE',
} as const;

/**
 * An Object containing Card Update Request

 */
export interface CardUpdateRequest {
  /** Reason for cancelling card. Only required if status is set to CANCELLED.
 */
  cancellingReason?: CardUpdateRequestCancellingReason;
  /** Clears daily cashwithdrawal limits on this card. Set value to TRUE to remove any daily cashwithdrawal limits. If set to TRUE, any maxCashWithdrawalLimit limit is ignored. You can still apply daily spend limits even when clearCashWithdrawalLimit is set to TRUE.
 */
  clearCashWithdrawalLimit?: boolean;
  /** Clears spending limits on this card. Set value to TRUE to remove any daily spending limits. If set to TRUE, any maxSpendLimit limit is ignored. You can still apply daily cash withdrawal limits  even when clearSpendLimit is set to TRUE.
 */
  clearSpendLimit?: boolean;
  /**
   * The total amount of cash that can be withdrawn in a single day. Resets at 00:00 each day.

   * @minimum 0
   */
  maxCashWithdrawalLimit?: number;
  /**
   * The maximum total amount that can be spent in a single day. Resets at 00:00 each day.

   * @minimum 0
   */
  maxSpendLimit?: number;
  /** 4 digit ATM pin to be used for associated card.
Optional field. Only include if setting a new PIN.
 */
  pin?: string;
  /** Reason for replacing card. Only required if status is set to REPLACED.
 */
  replacementReason?: CardUpdateRequestReplacementReason;
  /** New status of the card after request. Can be locked/unlocked/replaced/cancelled status.
Optional field. Only use if you want to update the status of the card.
 */
  status?: CardUpdateRequestStatus;
}

/**
 * The current status of the card.
 */
export type DebitCardStatus = typeof DebitCardStatus[keyof typeof DebitCardStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DebitCardStatus = {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SUSPEND: 'SUSPEND',
  DAMAGED: 'DAMAGED',
  DEACTIVE: 'DEACTIVE',
  DEFECTIVE: 'DEFECTIVE',
  LOST: 'LOST',
  STOLEN: 'STOLEN',
  UNDELIVER: 'UNDELIVER',
  IRREGACT: 'IRREGACT',
  OTHER: 'OTHER',
} as const;

export interface DebitCard {
  /** Account identifier or payment routing number. */
  accountId: string;
  /** Card expiration date. */
  expirationDate: string;
  /** First name of the client. */
  firstName: string;
  /** Unique identifier for the card. */
  id: string;
  /** Last Four digits of the card number. */
  last4: string;
  /** Last name of the client. */
  lastName: string;
  /**
   * The total amount of cash that can be withdrawn in a single day. Resets at 00:00 each day.
   * @minimum 0
   */
  maxCashWithdrawalLimit?: number;
  /**
   * The maximum total amount that can be spent in a single day. Resets at 00:00 each day.
   * @minimum 0
   */
  maxSpendLimit?: number;
  /** Middle name of the client. */
  middleName: string;
  /** The current status of the card. */
  status: DebitCardStatus;
}

export type CheckImageStatusFront = typeof CheckImageStatusFront[keyof typeof CheckImageStatusFront];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CheckImageStatusFront = {
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  NOT_SUBMITTED: 'NOT_SUBMITTED',
} as const;

export type CheckImageStatusBack = typeof CheckImageStatusBack[keyof typeof CheckImageStatusBack];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CheckImageStatusBack = {
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  NOT_SUBMITTED: 'NOT_SUBMITTED',
} as const;

/**
 * An object containing the status of a submitted image of a check.

 */
export interface CheckImageStatus {
  back?: CheckImageStatusBack;
  front?: CheckImageStatusFront;
}

export type CheckDepositResponseStatus = typeof CheckDepositResponseStatus[keyof typeof CheckDepositResponseStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CheckDepositResponseStatus = {
  PENDING: 'PENDING',
  CANCELLED: 'CANCELLED',
  COMPLETE: 'COMPLETE',
} as const;

/**
 * An object containing the response to a check deposit request.

 */
export interface CheckDepositResponse {
  /** Financial value (amount of money) of the check deposit.
 */
  amount?: number;
  checkImageStatus?: CheckImageStatus;
  /** Date the check was submitted.
 */
  createdAt?: string;
  /** Account identifier of the creditor (the party being paid). This should match the Embedded Banking account into which the funds will be transferred.
 */
  creditorAccount?: string;
  /** The currency of the check, in three-character ISO currency code.
 */
  currency?: string;
  /** Debtor ABA (American Bankers Association) Routing Number.
 */
  debtorABA?: string;
  /** Account identifier of the debtor (the party making the payment).
 */
  debtorAccount?: string;
  /** The name of the debtor (the party making the payment).
 */
  debtorName?: string;
  /** A unique identifier for the check.
 */
  id?: string;
  /** A message or description of the check for the end user's reference.
 */
  memo?: string;
  status?: CheckDepositResponseStatus;
}

/**
 * An object containing the check deposit request.

 */
export interface CheckDepositRequest {
  /** Account Identifier/ Payment Routing Number.
 */
  accountId: string;
  /** Financial value (amount of money) of the check deposit.
 */
  amount: number;
  /** The currency of the check, in three-character ISO currency code.
 */
  currency: string;
  /** A message or description of the check for the end user's reference.
 */
  memo?: string;
}

/**
 * month
 */
export type BillingMonth = typeof BillingMonth[keyof typeof BillingMonth];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingMonth = {
  JANUARY: 'JANUARY',
  FEBRUARY: 'FEBRUARY',
  MARCH: 'MARCH',
  APRIL: 'APRIL',
  MAY: 'MAY',
  JUNE: 'JUNE',
  JULY: 'JULY',
  AUGUST: 'AUGUST',
  SEPTEMBER: 'SEPTEMBER',
  OCTOBER: 'OCTOBER',
  NOVEMBER: 'NOVEMBER',
  DECEMBER: 'DECEMBER',
} as const;

/**
 * Billing period
 */
export type PeriodType = typeof PeriodType[keyof typeof PeriodType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PeriodType = {
  MONTHLY: 'MONTHLY',
} as const;

/**
 * Used to calculate transaction fee
 */
export type CalculationType = typeof CalculationType[keyof typeof CalculationType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CalculationType = {
  FLAT_RATE: 'FLAT_RATE',
  PERCENTAGE: 'PERCENTAGE',
} as const;

/**
 * Type of billing the client is enrolled in
 */
export type BillingType = typeof BillingType[keyof typeof BillingType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingType = {
  PAYG: 'PAYG',
  BUNDLE: 'BUNDLE',
  INVOICE: 'INVOICE',
} as const;

/**
 * Parent platform of the client
 */
export type Platform = typeof Platform[keyof typeof Platform];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Platform = {
  EB: 'EB',
} as const;

/**
 * Billing product sub-type
 */
export type BillingProductSubType = typeof BillingProductSubType[keyof typeof BillingProductSubType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingProductSubType = {
  ACH_PAYOUT: 'ACH_PAYOUT',
  WIRE_PAYOUT: 'WIRE_PAYOUT',
  RTP_PAYOUT: 'RTP_PAYOUT',
  DEBIT_CARD_REQUEST: 'DEBIT_CARD_REQUEST',
} as const;

/**
 * Billing product type
 */
export type BillingProductType = typeof BillingProductType[keyof typeof BillingProductType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingProductType = {
  TRANSACTION: 'TRANSACTION',
  DEBIT_CARD: 'DEBIT_CARD',
} as const;

/**
 * How the fee is going to be calculated on a pay as you go billing type or if the client has excedeed their allwance on a subscription.
 */
export type BillingEventCalculationType = typeof BillingEventCalculationType[keyof typeof BillingEventCalculationType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingEventCalculationType = {
  PERCENTAGE: 'PERCENTAGE',
  FLAT_AMOUNT: 'FLAT_AMOUNT',
} as const;

/**
 * The billing product type.
 */
export type BillingEventBillingEventType = typeof BillingEventBillingEventType[keyof typeof BillingEventBillingEventType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingEventBillingEventType = {
  TRANSACTION: 'TRANSACTION',
} as const;

/**
 * The billing product sub-type.
 */
export type BillingEventBillingEventSubType = typeof BillingEventBillingEventSubType[keyof typeof BillingEventBillingEventSubType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingEventBillingEventSubType = {
  ACH_PAYOUT: 'ACH_PAYOUT',
  RTP_PAYOUT: 'RTP_PAYOUT',
  WIRE_PAYOUT: 'WIRE_PAYOUT',
} as const;

export interface BillingEvent {
  /**
   * Allowance of the particular product per billing cycle if they are on a subscription.
   * @minimum 0
   */
  allowance?: number;
  /** The billing product sub-type. */
  billingEventSubType: BillingEventBillingEventSubType;
  /** The billing product type. */
  billingEventType: BillingEventBillingEventType;
  /** How the fee is going to be calculated on a pay as you go billing type or if the client has excedeed their allwance on a subscription. */
  calculationType: BillingEventCalculationType;
  /** Date when configuration comes into effect */
  effectiveDateFrom: string;
  /** Date when configuration ceases being in effect */
  effectiveDateTo: string;
  /** Rate to be used as billing fee - required for FLAT_RATE calculation type. Must be a non-negative decimal value */
  flatCharge?: number;
  /** Maximum fee to be applied if calculated billing fee is higher. Must be a non-negative decimal value - required for PERCENTAGE calculation type */
  maxCharge?: number;
  /** Minimum fee to be applied if calculated billing fee is lower. Must be a non-negative decimal value - required for PERCENTAGE calculation type */
  minCharge?: number;
  /** Percentage proportion for use in calculating billing fee - required for PERCENTAGE calculation type. Must be a positive decimal value between 0 to 1 (inclusive) */
  percentageValue?: number;
  /**
   * The amount of allwance used by the client so far if they are on a subscription.
   * @minimum 0
   */
  usage?: number;
}

/**
 * The type of billing the client is currently using.
 */
export type BillingClientDetailsResponseType = typeof BillingClientDetailsResponseType[keyof typeof BillingClientDetailsResponseType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingClientDetailsResponseType = {
  SUBSCRIPTION: 'SUBSCRIPTION',
  PAY_AS_YOU_GO: 'PAY_AS_YOU_GO',
} as const;

/**
 * The period when the client would be billed if they are on a subscription.
 */
export type BillingClientDetailsResponsePeriodType = typeof BillingClientDetailsResponsePeriodType[keyof typeof BillingClientDetailsResponsePeriodType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingClientDetailsResponsePeriodType = {
  MONTHLY: 'MONTHLY',
  YEARLY: 'YEARLY',
} as const;

/**
 * The charge currency.
 */
export type BillingClientDetailsResponseCurrency = typeof BillingClientDetailsResponseCurrency[keyof typeof BillingClientDetailsResponseCurrency];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingClientDetailsResponseCurrency = {
  USD: 'USD',
} as const;

/**
 * The month in which the client will be billed if they are on an yearly subscription.
 */
export type BillingClientDetailsResponseBillingMonth = typeof BillingClientDetailsResponseBillingMonth[keyof typeof BillingClientDetailsResponseBillingMonth];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BillingClientDetailsResponseBillingMonth = {
  JANUARY: 'JANUARY',
  FEBRUARY: 'FEBRUARY',
  MARCH: 'MARCH',
  APRIL: 'APRIL',
  MAY: 'MAY',
  JUNE: 'JUNE',
  JULY: 'JULY',
  AUGUST: 'AUGUST',
  SEPTEMBER: 'SEPTEMBER',
  OCTOBER: 'OCTOBER',
  NOVEMBER: 'NOVEMBER',
  DECEMBER: 'DECEMBER',
} as const;

export interface BillingClientDetailsResponse {
  /**
   * The day the client would be billed on if they are on a subcription.
   * @minimum 1
   * @maximum 31
   */
  billingDay?: number;
  /** The month in which the client will be billed if they are on an yearly subscription. */
  billingMonth?: BillingClientDetailsResponseBillingMonth;
  /**
   * The charge currency.
   */
  currency: BillingClientDetailsResponseCurrency;
  /** @minItems 0 */
  items: BillingEvent[];
  /** The date that the client will next be billed on if they are on a subscription. */
  nextBillingDate?: string;
  /** The period when the client would be billed if they are on a subscription. */
  periodType?: BillingClientDetailsResponsePeriodType;
  /**
   * The amount the client would be charged on the billing day if they are on a subscription.
   * @minimum 0.01
   */
  subscriptionCharge?: number;
  /** The name of the subscription package if the client is on a subscription. */
  subscriptionName?: string;
  /**
   * The type of billing the client is currently using.
   */
  type: BillingClientDetailsResponseType;
}

/**
 * Payment intent status
 */
export type PaymentIntentType = typeof PaymentIntentType[keyof typeof PaymentIntentType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PaymentIntentType = {
  PAYABLE: 'PAYABLE',
} as const;

/**
 * Payment intent status
 */
export type PaymentIntentStatus = typeof PaymentIntentStatus[keyof typeof PaymentIntentStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PaymentIntentStatus = {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  CANCELED: 'CANCELED',
  REJECTED: 'REJECTED',
  EXPIRED: 'EXPIRED',
  SCHEDULED: 'SCHEDULED',
} as const;

export type InternalPaymentIntentAllOf = {
  /** Party ID */
  partyId?: string;
};

export interface PaymentIntent {
  /** @minimum 0.01 */
  amount?: number;
  /** Generated balance hold Id of payable */
  balanceHoldId?: string;
  /** Date the payment intent was created. */
  createdAt?: string;
  /** Creditor's email */
  creditorEmail?: string;
  /** The name of the account holder receiving the payment. This is either the name of the account holder‚Äôs business or their first and last name. */
  creditorName?: string;
  /** The currency of the check, in three-character ISO currency code.
 */
  currency?: string;
  /** ID of the account to make the payment from. */
  debtorAccountId?: string;
  /** The last 4 digits of the debtor account number. The digits are preceded by ... to show that the account number has been masked. */
  debtorAccountNumber?: string;
  /** The name of the account holder making the payment. This is either the name of the account holder‚Äôs business or their first and last name. */
  debtorName?: string;
  /** ISO date format - yyyy-MM-dd. If no date provided, value should be set to 30 days from the current date. */
  expirationDate?: string;
  /** Payable ID */
  id?: string;
  /** Recipient ID */
  recipientId?: string;
  status?: PaymentIntentStatus;
  /** Generated transaction Id of payable */
  transactionId?: string;
  type?: PaymentIntentType;
}

export interface PaymentIntents {
  /**
   * List of payment intents meeting the request criteria
   * @minItems 0
   */
  items: PaymentIntent[];
  metadata: PageMetaData;
}

export type InternalPaymentIntent = PaymentIntent & InternalPaymentIntentAllOf;

export interface UpdatePaymentIntentRequest {
  status?: PaymentIntentStatus;
}

export interface PaymentIntentRequest {
  /** @minimum 0.01 */
  amount: number;
  /** Transaction currency
 */
  currency: string;
  /**
   * ID of the account to make the payment from.
   * @minLength 1
   * @maxLength 35
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  debtorAccountId?: string;
  /** ISO date format - yyyy-MM-dd. If no date is provided, value will be set to 10 days from the current date. */
  expirationDate?: string;
  /** Recipient ID */
  recipientId: string;
}

/**
 * An optional field present if a balance hold comes from a card transaction.
 */
export interface CardTransactionAttributes {
  /** The authorization code for the balance hold, returned to the merchant. */
  authCode: string;
  /** The last 4 digits of the card that was used to initiate the balance hold. */
  cardLast4: string;
  /** The ID of the card that was used to initiate the balance hold. */
  id: string;
  /** The name of the merchant where the balance hold was initiated. */
  merchantName: string;
}

export interface BalanceHold {
  /** The amount that was initially authorized. This could be different than the requested amount if partial authorizations take place. */
  authorizedAmount: string;
  /** The date and time in UTC at which the balance hold was created. */
  createdAt: string;
  /** The currency code used for the balance hold. */
  currency: string;
  /** The VAID of the account the balance hold is placed on. */
  debtorAccountId?: string;
  /** The PRN of the account the balance hold is placed on. */
  debtorAccountNumber: string;
  /** The date and time in UTC at which the balance hold will expire. */
  expiresAt: string;
  /** The full balance hold id. */
  id: string;
  /** The amount that is currently being held. */
  pendingAmount: string;
  /** The amount that was initially requested. */
  requestedAmount: string;
  /** The status of the balance hold. */
  status: string;
  typeSpecificAttributes: CardTransactionAttributes;
  /** The date and time in UTC at which any update was made to the balance hold. */
  updatedAt: string;
}

export interface BalanceHolds {
  /**
   * List of all holds on an account balance.
   * @minItems 0
   */
  items: BalanceHold[];
  metadata: PageMetaData;
}

export interface BalanceHoldGetResponse {
  /** The amount that was initially authorized. This could be different than the requested amount if partial authorizations take place. */
  authorizedAmount: number;
  /** The date and time in UTC at which the balance hold was created. */
  createdAt: string;
  /** The currency code used for the balance hold. */
  currency: string;
  /** The VAID of the account the balance hold is placed on. */
  debtorAccountId?: string;
  /** The PRN of the account the balance hold is placed on. */
  debtorAccountNumber: string;
  /** The date and time in UTC at which the balance hold will expire. */
  expirationDateTime: string;
  /** The full balance hold id. */
  id: string;
  /** The amount that is currently being held. */
  pendingAmount: number;
  /** The amount that was initially requested. */
  requestedAmount: number;
  /** The status of the balance hold. */
  status: string;
  typeSpecificAttributes: CardTransactionAttributes;
  /** The date and time in UTC at which any update was made to the balance hold. */
  updatedAt: string;
}

export interface ListBalanceHoldGetResponse {
  /**
   * List of all holds on an account balance.
   * @minItems 0
   */
  items: BalanceHoldGetResponse[];
  metadata: PageMetaData;
}

/**
 * Accounting type (Credit (CR) / Debit (DR)) for transaction
 */
export type AccountingType = typeof AccountingType[keyof typeof AccountingType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountingType = {
  DR: 'DR',
  CR: 'CR',
} as const;

/**
 * First line of the recipient's postal address.
For payment types ACH, WIRE and RTP routingCodeType, routingNumber and countryCode are required.
For payment type of ACH account type is required.

 */
export interface TransactionRecipientAccount {
  countryCode?: SchemasCountryCode;
  number: AccountNumber;
  routingCodeType?: RoutingCodeType;
  routingNumber?: RoutingNumber;
  type?: AccountType;
}

/**
 * Recipient's postal address
Mandatory for payment types WIRE, RTP

 */
export interface TransactionRecipientAddress {
  /**
   * First line of the recipient's postal address
For payment type WIRE addressLine1 cannot exceed 35 characters
For payment type RTP addressLine1 cannot exceed 70 characters

   * @minLength 1
   * @maxLength 70
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  addressLine1: string;
  /**
   * Second line of the recipient's postal address
   * @minLength 1
   * @maxLength 70
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  addressLine2?: string;
  /**
   * Third line of the recipient's postal address
   * @minLength 1
   * @maxLength 70
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  addressLine3?: string;
  /**
   * City of the recipient's postal address
For payment type WIRE city and state combined cannot exceed 35 characters

   * @minLength 1
   * @maxLength 35
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  city: string;
  countryCode: SchemasCountryCode;
  /**
   * State of the recipient's postal address
For payment type WIRE city and state combined cannot exceed 35 characters

   * @minLength 1
   * @maxLength 35
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  state: string;
  /**
   * Zip code of the recipient's postal address
   * @minLength 1
   * @maxLength 16
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  zip: string;
}

export interface TransactionRecipientPartyDetail {
  address?: TransactionRecipientAddress;
  /**
   * Recipient company name
Mandatory for recipient type ORGANIZATION
For payment type WIRE business name cannot exceed 35 characters

   * @maxLength 140
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  businessName?: string;
  /** @minItems 0 */
  contacts?: RecipientContact[];
  /**
   * Recipient's first name
Mandatory for recipient type INDIVIDUAL
For payment type WIRE firstName and lastName combined cannot exceed 35 characters

   * @maxLength 70
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  firstName?: string;
  /**
   * Recipient's last name
Mandatory for recipient type INDIVIDUAL
For payment type WIRE firstName and lastName combined cannot exceed 35 characters

   * @maxLength 70
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  lastName?: string;
  type?: PartyType;
}

/**
 * Payment recipient, either recipient or recipient id must be provided
 */
export interface TransactionRecipientDetails {
  account: TransactionRecipientAccount;
  partyDetails?: TransactionRecipientPartyDetail;
}

export interface TransactionsSearchResponse {
  accountingType?: AccountingType;
  /** Transaction amount */
  amount?: string;
  /** Transaction creation date */
  createdDate?: string;
  /** The date and time the transaction was created. */
  creationTimestamp?: string;
  /** The last 4 digits of the creditor account number (PRN). The digits are preceded by ... to show that the account number has been masked. */
  creditorAccount?: string;
  /** The name of the account holder receiving the payment. This is either the name of the account holder‚Äôs business or their first and last name. */
  creditorName?: string;
  /** Transaction currency */
  currency?: string;
  /** The last 4 digits of the debtor account number (PRN). The digits are preceded by ... to show that the account number has been masked. */
  debtorAccount?: string;
  /** The name of the account holder making the payment. This is either the name of the account holder‚Äôs business or their first and last name. */
  debtorName?: string;
  /** The time and date when the ledger balance was updated. */
  effectiveDate?: string;
  /** The ledger balance shows the total of all settled transactions at the time the request is made. Transactions which are in a pending state and transactions of type hold are excluded from this balance. The ledger balance is updated only when a transaction is settled. */
  ledgerBalance?: number;
  paymentRoute?: PaymentRoute;
  /** A measure of how many times an account has been updated by a new transaction. The posting version is incremented by 1 whenever there's a an event on the account. It can be used to track the order in which transactions have occurred, so you can present the user with the most recent transactions first. */
  postingVersion?: number;
  status?: TransactionStatus;
  /** Unique identifier of a transaction */
  transactionId?: string;
  transactionType?: TransactionType1;
}

export interface ListTransactionsSearchResponse {
  /**
   * List of transactions meeting the request criteria
   * @minItems 0
   */
  items: TransactionsSearchResponse[];
  metadata: PageMetaData;
}

/**
 * The types of transaction that the client is allowed to search by.
 */
export type RequestTransactionTypeV2 = typeof RequestTransactionTypeV2[keyof typeof RequestTransactionTypeV2];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RequestTransactionTypeV2 = {
  RTP: 'RTP',
  WIRE: 'WIRE',
  ACH: 'ACH',
  TRANSFER: 'TRANSFER',
  REVERSAL: 'REVERSAL',
  RETURN: 'RETURN',
  OTHER: 'OTHER',
  CARD: 'CARD',
  FEE: 'FEE',
} as const;

/**
 * The types of transaction that the client is allowed to search by.
 */
export type RequestTransactionType = typeof RequestTransactionType[keyof typeof RequestTransactionType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RequestTransactionType = {
  PAYIN: 'PAYIN',
  PAYOUT: 'PAYOUT',
  TRANSFER: 'TRANSFER',
  REVERSAL: 'REVERSAL',
  UNDEFINED: 'UNDEFINED',
  RETURN: 'RETURN',
  CARD: 'CARD',
  FEE: 'FEE',
} as const;

/**
 * The statuses of the transaction that the client is allowed to search by.
 */
export type RequestTransactionStatus = typeof RequestTransactionStatus[keyof typeof RequestTransactionStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RequestTransactionStatus = {
  PENDING: 'PENDING',
  CANCELED: 'CANCELED',
  COMPLETED: 'COMPLETED',
  COMPLETED_WITH_EXCEPTIONS: 'COMPLETED_WITH_EXCEPTIONS',
  REJECTED: 'REJECTED',
  RETURNED: 'RETURNED',
  PARTIALLY_COMPLETED: 'PARTIALLY_COMPLETED',
  UNDEFINED: 'UNDEFINED',
} as const;

/**
 * Defines the transaction according to specific types. For example, whether money has been paid into or out of the account.
 */
export type TransactionType1 = typeof TransactionType1[keyof typeof TransactionType1];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TransactionType1 = {
  PAYIN: 'PAYIN',
  PAYTO: 'PAYTO',
  PAYINTO: 'PAYINTO',
  TRANSFER: 'TRANSFER',
  PAYOUT: 'PAYOUT',
  PAYIN_REVERSAL: 'PAYIN_REVERSAL',
  PAYOUT_REVERSAL: 'PAYOUT_REVERSAL',
  MISC_CREDIT: 'MISC_CREDIT',
  MISC_DEBIT: 'MISC_DEBIT',
  UNDEFINED: 'UNDEFINED',
  PAYINTORECEIPT: 'PAYINTORECEIPT',
  PAYOUTCOLLECTION: 'PAYOUTCOLLECTION',
  PAYINTOCOLLECTION: 'PAYINTOCOLLECTION',
  PAYINTO_RETURN: 'PAYINTO_RETURN',
  PAYOUTCOLLECTION_RETURN: 'PAYOUTCOLLECTION_RETURN',
  PAYINTOCOLLECTION_RETURN: 'PAYINTOCOLLECTION_RETURN',
  RETURN: 'RETURN',
  CARD: 'CARD',
  FEE: 'FEE',
  BOOKTRANSFER: 'BOOKTRANSFER',
} as const;

/**
 * The current status of the transaction as it is processed:
 * `PENDING` - The transaction is still being processed.
 * `CANCELED` - The transaction has been canceled.
 * `COMPLETED` - The transaction has been completed.
 * `COMPLETED_WITH_EXCEPTIONS` - The transaction has completed, but not all of the requested criteria has been fulfilled.
 * `REJECTED` - The transaction has been rejected and will not be completed.
 * `RETURNED` - The payment rail has been unable to complete the payment specified recipient. The payment has been returned to the originator. 
 * `PARTIALLY_COMPLETED` - Not all transactions in the batch have been completed. 
 * `UNDEFINED` - The status of this transaction cannot be found.

 */
export type TransactionStatus = typeof TransactionStatus[keyof typeof TransactionStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TransactionStatus = {
  PENDING: 'PENDING',
  CANCELED: 'CANCELED',
  COMPLETED: 'COMPLETED',
  COMPLETED_WITH_EXCEPTIONS: 'COMPLETED_WITH_EXCEPTIONS',
  COMPLETED_NOT_IN_TARGET_WALLET: 'COMPLETED_NOT_IN_TARGET_WALLET',
  REJECTED: 'REJECTED',
  RETURNED: 'RETURNED',
  PARTIALLY_COMPLETED: 'PARTIALLY_COMPLETED',
  UNDEFINED: 'UNDEFINED',
} as const;

export interface TransactionsSearchRequest {
  /** Debtor account number which requested transactions should have. */
  accountNumber?: string;
  /**
   * Amount which requested transactions should have.
   * @pattern ^\d{0,15}(?:[.]\d{1,2})?$
   */
  amountEquals?: string;
  /**
   * Amount which requested transactions should be greater than.
   * @pattern ^\d{0,15}(?:[.]\d{1,2})?$
   */
  amountGreaterThan?: string;
  /**
   * Amount which requested transactions should be less than.
   * @pattern ^\d{0,15}(?:[.]\d{1,2})?$
   */
  amountLessThan?: string;
  /**
   * Date on which requested transactions should have occurred.
   * @pattern ^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$
   */
  dateEquals?: string;
  /**
   * Date after which requested transactions should have occurred.
   * @pattern ^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$
   */
  dateGreaterThan?: string;
  /**
   * Date before which requested transactions should have occurred.
   * @pattern ^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$
   */
  dateLessThan?: string;
  /** Date and time after which requested transactions should have occurred. */
  dateTimeGreaterThan?: string;
  /** Date and time before which requested transactions should have occurred. */
  dateTimeLessThan?: string;
  /** A transaction ID generated by other systems external to wallet, for instance WPI */
  externalId?: string;
  paymentType?: RequestTransactionType;
  /** Recipient account number which requested transactions should have. */
  recipientAccount?: string;
  /** Recipient ID provided by the client when initiating the transaction. */
  recipientId?: string;
  status?: RequestTransactionStatus;
  /** Transaction Identifier which requested transactions should have. */
  transactionId?: string;
  /** An alternate transaction ID provided by the client when initiating the transaction */
  transactionReferenceId?: string;
}

export interface MerchantAddress {
  addressLine1?: string;
  city?: string;
  countryCode?: string;
  state?: string;
  zip?: string;
}

export interface Merchant {
  address?: MerchantAddress;
  name?: string;
}

export interface DebitCardDetails {
  cardLast4?: string;
  cardPaymentRoutingNumber?: string;
  cardSerialNumber?: string;
  cardTransactionType?: string;
  isa?: string;
  merchant?: Merchant;
  messageType?: string;
  surcharge?: number;
}

export type InternalDebitCardDetails = DebitCardDetails & {
  authHoldId?: string;
};

export type TransactionGetResponseAllOf = {
  debitCardDetails?: DebitCardDetails;
  status?: TransactionStatus;
  transactionType?: TransactionType1;
};

export type TransactionGetResponse = TransactionGetResponseDetails & TransactionGetResponseAllOf;

export interface TransactionResponse {
  accountId?: string;
  accountNumber?: string;
  amount?: number;
  c2ProfileId?: string;
  currency?: string;
  debitCardDetails?: DebitCardDetails;
  id?: string;
  memo?: string;
  /** ISO date format - yyyy-MM-dd */
  paymentDate?: string;
  recipient?: TransactionRecipientDetails;
  status?: TransactionStatus;
  type?: PaymentType;
}

/**
 * The type of the fee transaction. Use this to differentiate between the fee transactions that were charged and those that were reversed. * CHARGE - the fee that was incurred as a result of a transaction. * REVERSAL - the fee was incurred and then voided on a transaction.
 */
export type FeeType = typeof FeeType[keyof typeof FeeType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FeeType = {
  CHARGE: 'CHARGE',
  REVERSAL: 'REVERSAL',
} as const;

/**
 * The transaction type of the originating transaction that incurred a fee. This is only available for fee transactions. * ACH_PAYOUT - the original transaction was a payout made by ACH payment route. * RTP_PAYOUT - the original transaction was a payout made by ACH payment route. * WIRE_PAYOUT - the original transaction was a payout made by WIRE payment route. * DEBIT_CARD_REQUEST - the original transaction was a debit card request. * FEE - the original transaction was a fee that was reversed.
 */
export type OriginatingTransactionType = typeof OriginatingTransactionType[keyof typeof OriginatingTransactionType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OriginatingTransactionType = {
  ACH_PAYOUT: 'ACH_PAYOUT',
  RTP_PAYOUT: 'RTP_PAYOUT',
  WIRE_PAYOUT: 'WIRE_PAYOUT',
  DEBIT_CARD_REQUEST: 'DEBIT_CARD_REQUEST',
  FEE: 'FEE',
} as const;

/**
 * The method by which the payment was made - RTP, WIRE, ACH
 */
export type PaymentRoute = typeof PaymentRoute[keyof typeof PaymentRoute];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PaymentRoute = {
  RTP: 'RTP',
  WIRE: 'WIRE',
  ACH: 'ACH',
} as const;

export interface TransactionGetResponseDetails {
  accountingType?: AccountingType;
  /** Transaction value */
  amount?: number;
  /** The date and time the transaction was created. */
  creationTimestamp?: string;
  /** The last 4 digits of the creditor account number - PRN or DDA. The digits are preceded by ... to show that the account number has been masked. */
  creditorAccount?: string;
  /** The name of the account holder receiving the payment. This is either the name of the account holder‚Äôs business or their first and last name. */
  creditorName?: string;
  /** Transaction currency */
  currency?: string;
  /** The last 4 digits of the debtor account number - PRN or DDA. The digits are preceded by ... to show that the account number has been masked. */
  debtorAccount?: string;
  /** The name of the account holder making the payment. This is either the name of the account holder‚Äôs business or their first and last name. */
  debtorName?: string;
  feeType?: FeeType;
  /** Transaction ID */
  id?: string;
  /** Memorandum */
  memo?: string;
  /** The transactionId of a transaction which incurred a fee. Use this ID to show the connection between a fee transaction and its originating transaction. This is only available for fee transactions. */
  originatingTransactionId?: string;
  originatingTransactionType?: OriginatingTransactionType;
  /** Date of transaction */
  paymentDate?: string;
  paymentRoute?: PaymentRoute;
  /** The reason a transaction was REJECTED or RETURNED. This is populated only for transactions with 'REJECTED' status. For all other transactions, the value is 'null'. */
  rejectedReason?: string;
}

/**
 * Payment method - ACH, RTP, WIRE, ACH, TRANSFER. Only ACH (for payouts) and TRANSFER (for payments between embedded accounts) are used in Embedded Payments transactions.
 */
export type PaymentType = typeof PaymentType[keyof typeof PaymentType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PaymentType = {
  RTP: 'RTP',
  WIRE: 'WIRE',
  ACH: 'ACH',
  TRANSFER: 'TRANSFER',
} as const;

/**
 * Payment currency - currently supported: USD
 */
export type PostTransactionRequestCurrency = typeof PostTransactionRequestCurrency[keyof typeof PostTransactionRequestCurrency];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostTransactionRequestCurrency = {
  USD: 'USD',
} as const;

export interface PostTransactionRequest {
  /**
   * @minimum 0.01
   */
  amount: number;
  /**
   * Payment currency - currently supported: USD
   */
  currency: PostTransactionRequestCurrency;
  /**
   * Memorandum
   * @minLength 1
   * @maxLength 140
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  memo?: string;
  /**
   * ID of the account to make the payment from
   * @minLength 1
   * @maxLength 35
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  originatingAccount: string;
  /**
   * ISO date format - yyyy-MM-dd
   */
  paymentDate: string;
  recipient?: TransactionRecipientDetails;
  /** Payment recipient Id, either recipient or recipient id must be provided */
  recipientId?: string;
  type: PaymentType;
}

/**
 * Defines the transaction according to specific types. For example, whether money has been paid into or out of the account.
 */
export type TransactionType = typeof TransactionType[keyof typeof TransactionType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TransactionType = {
  PAYIN: 'PAYIN',
  PAYTO: 'PAYTO',
  PAYINTO: 'PAYINTO',
  TRANSFER: 'TRANSFER',
  PAYOUT: 'PAYOUT',
  PAYIN_REVERSAL: 'PAYIN_REVERSAL',
  PAYOUT_REVERSAL: 'PAYOUT_REVERSAL',
  MISC_CREDIT: 'MISC_CREDIT',
  MISC_DEBIT: 'MISC_DEBIT',
  UNDEFINED: 'UNDEFINED',
  PAYINTORECEIPT: 'PAYINTORECEIPT',
  PAYOUTCOLLECTION: 'PAYOUTCOLLECTION',
  PAYINTOCOLLECTION: 'PAYINTOCOLLECTION',
  PAYINTO_RETURN: 'PAYINTO_RETURN',
  PAYOUTCOLLECTION_RETURN: 'PAYOUTCOLLECTION_RETURN',
  PAYINTOCOLLECTION_RETURN: 'PAYINTOCOLLECTION_RETURN',
  RETURN: 'RETURN',
  CARD: 'CARD',
  FEE: 'FEE',
  BOOKTRANSFER: 'BOOKTRANSFER',
} as const;

/**
 * The transaction type of the transaction. Some transaction types are not available to be initiated via API and are therefore not included in the transaction request type field.
 */
export type PaymentTypeResponse = typeof PaymentTypeResponse[keyof typeof PaymentTypeResponse];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PaymentTypeResponse = {
  RTP: 'RTP',
  WIRE: 'WIRE',
  ACH: 'ACH',
  TRANSFER: 'TRANSFER',
  REVERSAL: 'REVERSAL',
  RETURN: 'RETURN',
  OTHER: 'OTHER',
  CARD: 'CARD',
  FEE: 'FEE',
} as const;

export interface TransactionsSearchResponseV2 {
  /** Transaction amount */
  amount?: number;
  /** The date and time the transaction was created. */
  createdAt?: string;
  /** The last 4 digits of the creditor account number (PRN). The digits are preceded by ... to show that the account number has been masked. */
  creditorAccountId?: string;
  /** The last 4 digits of the creditor account number (PRN). The digits are preceded by ... to show that the account number has been masked. */
  creditorAccountNumber?: string;
  /** The clientId of the client whose account is to be credited. */
  creditorClientId?: string;
  /** The name of the account holder receiving the payment. This is either the name of the account holder‚Äôs business or their first and last name. */
  creditorName?: string;
  /** Transaction currency */
  currency?: string;
  /** ID of the account to make the payment from. */
  debtorAccountId?: string;
  /** The last 4 digits of the debtor account number (PRN). The digits are preceded by ... to show that the account number has been masked. */
  debtorAccountNumber?: string;
  /** The clientId of the client whose account is to be debited. */
  debtorClientId?: string;
  /** The name of the account holder making the payment. This is either the name of the account holder‚Äôs business or their first and last name. */
  debtorName?: string;
  /** The date on which this transaction affected the ledger balance. This can be used in conjunction with postingVersion, to present the user with transactions with the ledgerBalance correctly ordered. */
  effectiveDate?: string;
  /** JPMC-generated unique identifier of a transaction */
  id?: string;
  /** The ledger balance shows the total of all settled transactions at the time the request is made. Transactions which are in a pending state and transactions of type hold are excluded from this balance. The ledger balance is updated only when a transaction is settled. */
  ledgerBalance?: number;
  /** ID to show the connection between this transaction and its originating transaction. */
  originatingId?: string;
  originatingTransactionType?: OriginatingTransactionType;
  /** Transaction creation date in YYYY-MM-DD format. */
  paymentDate?: string;
  /** A measure of how many times an account has been updated by a new transaction. The posting version is incremented by 1 whenever there's a an event on the account. It can be used to track the order in which transactions have occurred on a given effective date, so you can present the user with the most recent transactions first. */
  postingVersion?: number;
  /** Reference to the defined payment recipient object */
  recipientId?: string;
  status?: TransactionStatus;
  /** Transaction reference id provided by client */
  transactionReferenceId?: string;
  type?: PaymentTypeResponse;
}

export interface ListTransactionsSearchResponseV2 {
  /**
   * List of transactions meeting the request criteria
   * @minItems 0
   */
  items: TransactionsSearchResponseV2[];
  metadata: PageMetaData;
}

export interface TransactionGetResponseDetailsV2 {
  /** Transaction value */
  amount?: number;
  /** The date and time the transaction was created. */
  createdAt?: string;
  /** ID of the on-us account to which to make the payment. */
  creditorAccountId?: string;
  /** The last 4 digits of the creditor account number - PRN or DDA. The digits are preceded by ... to show that the account number has been masked. */
  creditorAccountNumber?: string;
  /** The clientId of the client whose account is to be credited. */
  creditorClientId?: string;
  /** The name of the account holder receiving the payment. This is either the name of the account holder‚Äôs business or their first and last name. */
  creditorName?: string;
  /** Transaction currency */
  currency?: string;
  /** ID of the on-us account from which to make the payment. */
  debtorAccountId?: string;
  /** The last 4 digits of the debtor account number - PRN or DDA. The digits are preceded by ... to show that the account number has been masked. */
  debtorAccountNumber?: string;
  /** The clientId of the client whose account is to be debited. */
  debtorClientId?: string;
  /** The name of the account holder making the payment. This is either the name of the account holder‚Äôs business or their first and last name. */
  debtorName?: string;
  /** The time and date when the ledger balance was updated. */
  effectiveDate?: string;
  error?: ApiErrorV2;
  feeType?: FeeType;
  /** Transaction ID */
  id?: string;
  /** The ledger balance shows the total of all settled transactions at the time the request is made. Transactions which are in a pending state and transactions of type hold are excluded from this balance. The ledger balance is updated only when a transaction is settled. */
  ledgerBalance?: number;
  /** Memorandum */
  memo?: string;
  /** ID to show the connection between this transaction and its originating transaction. */
  originatingId?: string;
  originatingTransactionType?: OriginatingTransactionType;
  /** Transaction date in ISO date format - yyyy-MM-dd */
  paymentDate?: string;
  /** A measure of how many times an account has been updated by a new transaction. The posting version is incremented by 1 whenever there's a an event on the account. It can be used to track the order in which transactions have occurred, so you can present the user with the most recent transactions first. */
  postingVersion?: number;
  /** Reference to the defined payment recipient object */
  recipientId?: string;
  /** Transaction reference id provided by client */
  transactionReferenceId?: string;
  type?: PaymentTypeResponse;
}

export type TransactionGetResponseV2AllOf = {
  status?: TransactionStatus;
};

export type TransactionGetResponseV2 = TransactionGetResponseDetailsV2 & TransactionGetResponseV2AllOf;

export interface TransactionResponseV2 {
  /**
   * Transaction value
   */
  amount: number;
  /** The date and time the transaction was created. */
  createdAt: string;
  /** ID of the on-us account to which to make the payment. */
  creditorAccountId?: string;
  /** The last 4 digits of the creditor account number - PRN or DDA. The digits are preceded by ... to show that the account number has been masked. */
  creditorAccountNumber?: string;
  /** The name of the account holder receiving the payment. This is either the name of the account holder‚Äôs business or their first and last name. */
  creditorName?: string;
  /**
   * Transaction currency
   */
  currency: string;
  /** ID of the on-us account from which to make the payment. */
  debtorAccountId?: string;
  /** The last 4 digits of the debtor account number - PRN or DDA. The digits are preceded by ... to show that the account number has been masked. */
  debtorAccountNumber?: string;
  /** The name of the account holder making the payment. This is either the name of the account holder‚Äôs business or their first and last name. */
  debtorName?: string;
  /** JPMC-generated unique ID for the transaction. */
  id?: string;
  /** Memorandum */
  memo?: string;
  /**
   * Transaction date in ISO date format - yyyy-MM-dd
   */
  paymentDate: string;
  /** Reference to the defined payment recipient object */
  recipientId?: string;
  status: TransactionStatus;
  /**
   * Transaction reference ID provided by client
   */
  transactionReferenceId?: string;
  type?: PaymentTypeResponse;
}

/**
 * Payment recipient, either recipient or recipient id must be provided for Payouts
 */
export interface TransactionRecipientDetailsV2 {
  account: SchemasTransactionRecipientAccount;
  partyDetails?: SchemasRecipientPartyDetails;
}

/**
 * Transaction currency
 */
export type PostTransactionRequestV2Currency = typeof PostTransactionRequestV2Currency[keyof typeof PostTransactionRequestV2Currency];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostTransactionRequestV2Currency = {
  USD: 'USD',
} as const;

export interface PostTransactionRequestV2 {
  /**
   * Transaction value in the given currency
   * @minimum 0.01
   */
  amount: number;
  /**
   * ID of the account to make the payment to.
   * @minLength 1
   * @maxLength 35
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  creditorAccountId?: string;
  /**
   * Transaction currency
   */
  currency: PostTransactionRequestV2Currency;
  /**
   * ID of the account to make the payment from.
   * @minLength 1
   * @maxLength 35
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  debtorAccountId?: string;
  /**
   * Memorandum
   * @maxLength 140
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  memo?: string;
  recipient?: TransactionRecipientDetailsV2;
  /** Reference to the defined payment recipient object */
  recipientId?: string;
  /**
   * A unique reference ID that you must generate and provide for each transaction.
   * @minLength 1
   * @maxLength 35
   * @pattern ^(.|\s)*\S(.|\s)*$
   */
  transactionReferenceId?: string;
  type?: PaymentType;
}

/**
 * @minItems 0
 * @maxItems 100
 */
export type ProductTypesArray = ProductType[];

export interface DocumentsDetails {
  documentType?: string;
  id?: string;
  /**
   * @minItems 0
   * @maxItems 100
   */
  metadata?: DocumentMetadata[];
  productTypes?: ProductTypesArray;
}

/**
 * @minItems 0
 */
export type DocumentsDetailsArray = DocumentsDetails[];

export interface ListDocumentsDetailsResponse {
  items?: DocumentsDetailsArray;
  metadata?: PageMetaData;
}

export interface DocumentDetails {
  documentType?: DocumentType;
  /** The unique id generated by the system for the uploaded document,  which can be used for future retrieval.
 */
  id?: string;
  /**
   * @minItems 0
   * @maxItems 2
   */
  metadata?: DocumentMetadata[];
  productType?: ProductType;
}

/**
 * Key value can be PARTY_ID or COUNTRY_CODE
 */
export type DocumentMetadataKey = typeof DocumentMetadataKey[keyof typeof DocumentMetadataKey];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DocumentMetadataKey = {
  PARTY_ID: 'PARTY_ID',
  COUNTRY_CODE: 'COUNTRY_CODE',
} as const;

/**
 * - Additional information about the document in a key-value pair array.
- The processing domain should only support the specific keys for thier relevant workflows.
- The productType and documentType combination will determine the 
  list of allowed meta-data keys and the format of their values.
    - For productype = EB and documentType = ( PASSPORT | SSN_CARD | DRIVERS_LICENSE | GOV_ISSUED_ID_CARD ),

      Mandatory meta-data key list = ["partyId"] and allowed meta-data value format = ["uuid"].

      Example - {"key": "partyId", "value": "73bd1c1d-6635-43ff-a8e5-b252926bdd9e"} .

 */
export interface DocumentMetadata {
  /** Key value can be PARTY_ID or COUNTRY_CODE */
  key: DocumentMetadataKey;
  /**
   * value can be UUID which represents a partyId or a ISO two characters country code e.g. US
   * @minLength 1
   * @maxLength 50
   */
  value: string;
}

/**
 * Product type identifies which domain the document is being uploaded to.
 */
export type ProductType = typeof ProductType[keyof typeof ProductType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProductType = {
  EB: 'EB',
  EP: 'EP',
} as const;

/**
 * Supported document types.
 */
export type DocumentType = typeof DocumentType[keyof typeof DocumentType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DocumentType = {
  IRS_DOCUMENT_TIN: 'IRS_DOCUMENT_TIN',
  ARTICLES_OF_INCORPORATION: 'ARTICLES_OF_INCORPORATION',
  MOA: 'MOA',
  MAA: 'MAA',
  CONSTITUTIONAL_DOCUMENT: 'CONSTITUTIONAL_DOCUMENT',
  TRUST_DEED: 'TRUST_DEED',
  PARTNERSHIP_AGREEMENT: 'PARTNERSHIP_AGREEMENT',
  LLC_AGREEMENT: 'LLC_AGREEMENT',
  OPERATING_AGREEMENT: 'OPERATING_AGREEMENT',
  OFFERING_MEMO: 'OFFERING_MEMO',
  BANKING_LICENSE: 'BANKING_LICENSE',
  BUSINESS_LICENSE: 'BUSINESS_LICENSE',
  BUSINESS_REGISTRATION_CERT: 'BUSINESS_REGISTRATION_CERT',
  OTHER_GOV_REGISTRATION_DOCS: 'OTHER_GOV_REGISTRATION_DOCS',
  SEC_FILINGS_10K: 'SEC_FILINGS_10K',
  PASSPORT: 'PASSPORT',
  SSN_CARD: 'SSN_CARD',
  DRIVERS_LICENSE: 'DRIVERS_LICENSE',
  GOV_ISSUED_ID_CARD: 'GOV_ISSUED_ID_CARD',
  TERMS_CONDITION: 'TERMS_CONDITION',
  DISCLOSURE_AND_CONSENT: 'DISCLOSURE_AND_CONSENT',
} as const;

export interface DocumentUploadData {
  documentType: DocumentType;
  /**
   * @minItems 0
   * @maxItems 2
   */
  metadata?: DocumentMetadata[];
  productType: ProductType;
}

/**
 * The product onboarding status
 */
export type OnboardingStatus = typeof OnboardingStatus[keyof typeof OnboardingStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OnboardingStatus = {
  INITIAL_PROFILE_CREATED: 'INITIAL_PROFILE_CREATED',
  REQUEST_RECEIVED: 'REQUEST_RECEIVED',
  SUBMITTED_FOR_PROCESSING: 'SUBMITTED_FOR_PROCESSING',
  KYC_REVIEW: 'KYC_REVIEW',
  CIP_COMPLETE: 'CIP_COMPLETE',
  KYC_COMPLETE: 'KYC_COMPLETE',
  ONBOARDING_COMPLETE: 'ONBOARDING_COMPLETE',
  ACCOUNT_CREATED: 'ACCOUNT_CREATED',
  BILLING_CONFIG_CREATED: 'BILLING_CONFIG_CREATED',
  GPP_CREATED: 'GPP_CREATED',
  ISSUE_ADDITIONAL_INFO_REQUESTED: 'ISSUE_ADDITIONAL_INFO_REQUESTED',
  ISSUE_INFO_RETURNED_TO_CDD: 'ISSUE_INFO_RETURNED_TO_CDD',
  PENDING_ONBOARDING_TERMINATION: 'PENDING_ONBOARDING_TERMINATION',
  ONBOARDING_TERMINATED: 'ONBOARDING_TERMINATED',
  OFFBOARDING_PENDING: 'OFFBOARDING_PENDING',
  OFFBOARDING_COMPLETE: 'OFFBOARDING_COMPLETE',
} as const;

export type Action = typeof Action[keyof typeof Action];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Action = {
  ADD: 'ADD',
  UPDATE: 'UPDATE',
  REMOVE: 'REMOVE',
} as const;

export type ProfileConfigurationOnboardedProductsItem = {
  onboardingStatus?: OnboardingStatus;
  /** Name of product */
  product?: string;
};

export interface ProfileConfiguration {
  /** Date the profile was created.
 */
  createdAt?: string;
  /** Once KYC has completed and approved, clients will be able to make payments out of their Embedded Bank Account. This flag will be set to FALSE until this process completes. Only present for clients.
 */
  enablePayouts?: boolean;
  /**
   * @minItems 0
   * @maxItems 256
   */
  onboardedProducts?: ProfileConfigurationOnboardedProductsItem[];
  /** The client onboarding status */
  onboardingStatus?: string;
  /** Client ID of the platform entity the client is onboarded to.
 */
  parentClientId?: string;
  /** active | deleted */
  profileStatus?: string;
}

/**
 * Phone Number Information of the account

 */
export interface Phone {
  /**
   * The ISO calling code for the phone number.
   * @minLength 1
   * @maxLength 10
   * @pattern ^(0{2}|\+)?[1-9]{1,3}$
   */
  countryCode: string;
  /**
   * @minLength 7
   * @maxLength 14
   * @pattern ^[0-9]{7,14}$
   */
  phoneNumber: string;
}

export interface AddressDto {
  /**
   * addressLine1 must not be a PO Box and must begin with a number.addressLine1 has a maximum of 34 characters. addressLine1 is mandatory when client is created.
   * @maxLength 34
   * @pattern (?=.*\d)(?=.*[A-Za-z])^\d.*$|^[NSEWnsew]\d.*$
   */
  addressLine1: string;
  /**
   * addressLine2 has a maximum of 34 characters.
   * @maxLength 34
   * @pattern [\p{L}\p{M}\p{N}\p{P}\p{Z}\p{Cf}\p{Cs}\s]*
   */
  addressLine2?: string;
  /**
   * addressLine3 has a maximum of 34 characters.
   * @maxLength 34
   * @pattern [\p{L}\p{M}\p{N}\p{P}\p{Z}\p{Cf}\p{Cs}\s]*
   */
  addressLine3?: string;
  /** Type of address e.g. 'Primary Residence' | 'Principal place of business'. */
  addressType?: string;
  /**
   * city has a maximum of 34 characters.
   * @maxLength 34
   * @pattern [\p{L}\p{M}\p{N}\p{P}\p{Z}\p{Cf}\p{Cs}\s]*
   */
  city: string;
  /** Country code in alpha-2 format. */
  countryCode: string;
  /**
   * Postal/ZIP code.
   * @maxLength 10
   * @pattern ^[\\p{IsLatin}0-9- \\.]+$
   */
  postalCode: string;
  /**
   * State code in alpha-2 format. State is mandatory for countries like United States.
   * @maxLength 2
   * @pattern ^[a-z-A-Z ]+$
   */
  state?: string;
}

export interface IdentityDTO {
  /** Description of identification type e.g. Social Security Number */
  idDescription?: string;
  /** Identification issuer country code e.g. US */
  idIssuer: string;
  /** IdType denotes the type of taxpayer identification numbers e.g. SSN/EIN. EIN is acceptable idType for Privately Owned Business. Sole Proprietorship can have EIN/SSN as idType. For individuals like Owners and Controllers SSN is accepted as idType. Decision Makers do not require any tax identifier.
 */
  idType: string;
  /**
   * Value of the identification type. EIN/SSN must be of 9 digits.
   * @pattern [0-9A-Za-z-]+
   */
  idValue: string;
}

export interface PartyDetailCommon {
  address?: AddressDto;
  /**
   * @minItems 0
   * @maxItems 100
   */
  identities?: IdentityDTO[];
  phone?: Phone;
}

export type RelatedPartyAllOf = {
  /**
   * The date of birth (yyyy-MM-dd) of the individual in case of party type being an individual. This field is not required for the party type Organization.

   * @pattern ([0-9]{4})-(?:[0-9]{2})-([0-9]{2})
   */
  birthDate?: string;
  /**
   * The business‚Äôs legal name. It is the official name of the person or entity that owns a company. And, it‚Äôs the name used on your government forms and business paperwork. This field is only required when party type is NonIndividual

   * @pattern ^(?![-.%/+&@,';:#()_])(?!.*[-.%/+&@,';:#()_]{2})(?!.*[-.%/+&@,';:#()_]$).*$
   */
  businessName?: string;
  /**
   * Email of the individual.

   * @maxLength 50
   * @pattern (^$)|(^([^,:;=@"'\s()\[\]]+)+@([a-zA-Z-0-9-]+\.)+[a-zA-Z]{2,}$)
   */
  email?: string;
  /**
   * First name of the individual in case of party type being an individual like Owners, Controllers and Decision Makers.

   * @minLength 2
   * @maxLength 30
   * @pattern ^(?![-.',])(?!.*[-.',]{2})(?!.*[-.',]$)[a-zA-Z-.', ]*$
   */
  firstName?: string;
  /** Job title in case of party type being an individual. JobTitle is required field for Controllers. Also, If Privately Owned Business is selected as the business type, Job Title should be a required field for Decision Makers. e.g. CEO|CFO|COO|President|Chairman|Senior Branch Manager|Other
 */
  jobTitle?: string;
  /**
   * In case on jobTitle is Other then Job title description is required.

   * @maxLength 50
   */
  jobTitleDescription?: string;
  /**
   * Last name of the individual in case of party type being an individual like Owners, Controllers and Decision Makers.

   * @minLength 2
   * @maxLength 30
   * @pattern ^(?![-.',])(?!.*[-.',]{2})(?!.*[-.',]$)[a-zA-Z-.', ]*$
   */
  lastName?: string;
  /**
   * Middle name of the individual in case of party type being an individual.

   * @maxLength 30
   * @pattern ^(?![-.',])(?!.*[-.',]{2})(?!.*[-.',]$)[a-zA-Z-.', ]*$
   */
  middleName?: string;
  /** Nature of ownership e.g. Direct|Indirect
 */
  natureOfOwnership?: string;
  /**
   * A Party role which could have one or more of the following values: CLIENT, CONTROLLER, MARKETPLACE_OPERATOR, OWNER, PAYEE, DECISION_MAKER
If a SMB controller and owner is the same person - you have to send two parties with the distinct partyRoles e.g. [ CLIENT, CONTROLLER, MARKETPLACE_OPERATOR, OWNER, DECISION_MAKER ]

   * @minItems 0
   * @maxItems 100
   */
  partyRole?: string[];
  /** A Party type which could have one of the following distinct values: Organization, Individual, NonIndividual
 */
  partyType?: string;
  soleOwner?: boolean;
};

export type RelatedParty = PartyDetailCommon & RelatedPartyAllOf;

export type RelatedPartyRequestAllOf = { [key: string]: any };

export type RelatedPartyRequest = RelatedParty & RelatedPartyRequestAllOf;

export type RelatedPartyResponseAllOf = {
  /** Individual/NonIndividual client id, as UUID, that uniquely identifies the resource.
 */
  id: string;
  /** Status of the request. Can be active or deleted. */
  status?: string;
};

export type RelatedPartyResponse = RelatedParty & RelatedPartyResponseAllOf;

export type ClientInformationResponseAllOf = {
  /** Date the profile was created.
 */
  createdAt?: string;
  /** Once KYC has completed and approved, clients will be able to make payments out of their Embedded Bank Account.
This flag will be set to FALSE until this process completes. Only present for clients.
 */
  enablePayouts?: boolean;
  /** Client ID. The unique identifier for a client.
 */
  id: string;
  /** The jurisdiction where the client would be onboarding.
 */
  jurisdiction?: string;
  /** The client onboarding status */
  onboardingStatus?: string;
  /** Client ID of the platform entity the client is onboarded to.
 */
  parentClientId?: string;
  /**
   * The products available for clients in a jurisdiction.

   * @minItems 0
   * @maxItems 100
   */
  products?: string[];
  /**
   * @minItems 0
   * @maxItems 100
   */
  relatedParties?: RelatedPartyResponse[];
  /** active | deleted */
  status?: string;
};

export type ClientInformationResponse = PartyDetailBusiness & ClientInformationResponseAllOf;

export interface ListClientInformationResponse {
  /**
   * @minItems 0
   * @maxItems 100
   */
  items?: ClientInformationResponse[];
  metadata?: PageMetaData;
}

export type RelatedPartiesRequest = RelatedPartyRequest;

export type PartyDetailBusinessAllOf = {
  /** Any alias names for the business connected to the client.
 */
  businessAliasName?: string;
  /** The business‚Äôs description.
 */
  businessDescription?: string;
  /**
   * The business‚Äôs legal name. It is the official name of the person or entity that owns a company. Must be the name used on the client's government forms and business paperwork

   * @pattern ^(?![-.%/+&@,';:#()_])(?!.*[-.%/+&@,';:#()_]{2})(?!.*[-.%/+&@,';:#()_]$).*$
   */
  businessName?: string;
  /** The type of business connected to the client. You can use the Reference Data resource to get a list of acceptable values. Examples include: Privately Owned Business. Sole Proprietorship.
 */
  businessType?: string;
  /** Country code in alpha-2 format */
  countryOfFormation?: string;
  /**
   * Email of the client.

   * @maxLength 50
   * @pattern (^$)|(^([^,:;=@"\\\s()\[\]]+)+@([a-zA-Z-0-9-]+\.)+[a-zA-Z]{2,}$)
   */
  email?: string;
  /** Entities in ownership means that one or more businesses own part of the business conected to the client. Always required for a Privately Owned Business.
 */
  entitiesInOwnership?: boolean;
  /** The industry category of the business connected to the client. For example, Accommodation and Food Services. You can use the Reference Data resource to get a list of acceptable values.
 */
  industryCategory?: string;
  /** The industry type of the business connected to the client. You can use the Reference Data resource to get a list of acceptable values.
 */
  industryType?: string;
  /** Legal Structure of the business entity. Legal structure is required for Privately Owned Business and Sole Proprietorship. Distinct legal structure. e.g. - Limited Liability Company - Corporation - Limited Partnership - Sole Proprietorship
 */
  legalStructure?: string;
  /** The parent (platform) relationship owner's ID. */
  parentClientId?: string;
  /** Significant ownership means there individuals who own 25% or more of the client's business. Always required for a Privately Owned Business. If Significant Ownership is selected as True, At least one related party should have the role of owner.
 */
  significantOwnership?: boolean;
  /**
   * Website of the business connected to the client. Always required if websiteAvailable is true.

   * @pattern ^((http|https|HTTP|HTTPS):\/\/)?(www.|WWW.)?(?!.*(http|HTTP|https|HTTPS|www.|WWW.))[a-zA-Z0-9_-]+(\.[a-zA-Z]+)+((\/)[\w#]+)*(\/\w+\?[a-zA-Z0-9_]+=\w+(&[a-zA-Z0-9_]+=\w+)*)?\/?$
   */
  website?: string;
  /** Whether or not the business connected to the client has a website.
 */
  websiteAvailable?: boolean;
  /**
   * Year of company formation. Max and Min length is 4.

   * @pattern ^(19|20)[0-9]+
   */
  yearOfFormation?: string;
};

export type PartyDetailBusiness = PartyDetailCommon & PartyDetailBusinessAllOf;

export type PartyDetailBusinessResponseAllOf = { [key: string]: any };

export type PartyDetailBusinessResponse = PartyDetailBusiness & PartyDetailBusinessResponseAllOf;

export type PartyDetailBusinessRequestAllOf = { [key: string]: any };

export type PartyDetailBusinessRequest = PartyDetailBusiness & PartyDetailBusinessRequestAllOf;

export type EntityDetailBusinessRequest = PartyDetailBusinessRequest;

export type CreateClientRequestAllOf = {
  /** The jurisdiction where the client would be onboarding.
 */
  jurisdiction?: string;
  /**
   * The products available for clients in a jurisdiction.

   * @minItems 0
   * @maxItems 100
   */
  products: string[];
  /** @minItems 0 */
  relatedParties: RelatedPartiesRequest[];
};

export type CreateClientRequest = EntityDetailBusinessRequest & CreateClientRequestAllOf;

export interface DocumentResponse {
  id?: string;
}

