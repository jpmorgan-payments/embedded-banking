# What is the SDK for

We understand that having to build code from scratch by looking at our API specification is time taking and effortful. And to help make your developer experience better, this guide will give you an overview on how you can turn the API specification into code by using the Open API Generator

There are multiple ways to use the OpenAPI Generator, but in this guide we will only be looking at its plugin capability - https://openapi-generator.tech/docs/plugins

Please note, the code generated by the OpenAPI Generator is only to act as a base for you to build your application on top of, for your business needs. And the base generated code will contain
1. Java object for request/response
2. API classes for all api's in the specification - to perform GET/POST requests
3. APIClient which has the core logic to make api requests and receive responses

The OpenAPI Generator doesnt generate code for Mutual TLS authentication – which is required to interact with any JPMorgan Payments API’s as of this moment.

To address the same, please follow the instructions below on how you can add custom code to enable the mTLS authentication on top of the OpenAPI generated code.

![img.png](img.png)

Please note, the below instructions were tested against the following specification versions along with mTLS authentication

- Embedded Payments API - v1.0.9
- Embedded Payments API - v2.0.9
- Digital Onboarding API - v1.0.8

## 1. Pre-requisites

### Open API Specification

Download the API spec files from https://developer.payments.jpmorgan.com/api/embedded-banking-solutions/embedded-payments/overview, for the product whose API's you wish to use
There could be multiple specs that you can download, if for example you need to interact with both Embedded Payments and Digital Onboarding API's

### Project technical requirements
1. The application needs to be of java language -jdk17 or above.
2. The application uses maven for dependency management.
3. The application uses spring framework – spring3


## 2. Steps to generate the SDK:
1. Create a java project with jdk17 or above and maven for dependency management
2. Create a folder in the root directory of your project, to store all the spec file(s) downloaded earlier from Payments Developer Portal
3. In the pom file of your application, add the OpenAPI Generator plugin.
    1. There are multiple ways to configure the plugin, more details at https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator-maven-plugin'
    2. Since you may have multiple spec files, a reference on how to configure the plugin can be found at - [pom file](pom.xml)
    3. The models/api's generated with the reference configuration at [pom.xml](pom.xml), use commonly used annotations from jackson,jakarta and spring. Please make sure you have the following dependencies added to your pom file
   ```xml
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-web</artifactId>
      <version>6.1.12</version>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context</artifactId>
      <version>6.1.12</version>
    </dependency> 
   <dependency>
      <groupId>org.openapitools</groupId>
      <artifactId>jackson-databind-nullable</artifactId>
      <version>0.2.6</version>
    </dependency>
    <dependency>
      <groupId>jakarta.annotation</groupId>
      <artifactId>jakarta.annotation-api</artifactId>
      <version>3.0.0</version>
    </dependency>
   ```
4. Once the plugin is setup, to enable mutual TLS authentication and payload signing capability on top OpenAPI Generators auto generated code, you could add the following code under the sources in your project
    1. MtlsConfiguration - [see here](src/main/java/net/jpmchase/architecture/config/MTLSConfiguration.java)
    2. RestTemplateConfigurer -  [see here](src/main/java/net/jpmchase/architecture/config/RestTemplateConfigurer.java)
    3. Please note that the code above will need the following dependencies added to your pom file
  ```xml
  <dependency>
      <groupId>io.jsonwebtoken</groupId>
      <artifactId>jjwt-api</artifactId>
      <version>0.11.5</version>
   </dependency>
   <dependency>
      <groupId>io.jsonwebtoken</groupId>
      <artifactId>jjwt-impl</artifactId>
      <version>0.11.5</version>
   </dependency>
   <dependency>
      <groupId>io.jsonwebtoken</groupId>
      <artifactId>jjwt-jackson</artifactId>
      <version>0.11.5</version>
   </dependency>
   <dependency>
      <groupId>org.apache.httpcomponents.client5</groupId>
      <artifactId>httpclient5</artifactId>
      <version>5.3.1</version>
   </dependency>
   ``` 

Now, you are all set to execute the open api generator plugin to auto generate code using the open api spec downloaded from Payments Developer Portal, along with MTLS authentication as an add on.

Execute the below command to trigger the OpenAPI Generator plugin to generate code, the output of which will be generated into the output directory you configured on the plugin.

```shell
mvn clean compile
```

## 3. Steps to use the SDK

You could either use the above project to implement your business interaction with JPMorgan payments API's or  package the above generated code above as an artifact to use in your business project.

### Getting Started against the mock - without mTLS Auth

You can find examples on how to use the code you generated to trigger an API request from the Junit tests [here](src/test/java/net/jpmchase/architecture/mock)

Please note that the tests above are set to run against our mock environment - https://api-mock.payments.jpmorgan.com/ and do not require any type of authentication.

To execute the tests from commandline, use the below command:
```shell
mvn test
```

### Getting Started against the real API - with mTLS auth

As you are ready to code against the real API, please find below an example on how to use the SDK with mTLS authentication.

```java

// Import classes:

import com.app.jpmorgan.payments.ApiClient;
import com.app.jpmorgan.payments.ApiException;
import com.app.jpmorgan.payments.Configuration;
import com.app.jpmorgan.payments.auth.*;
import com.app.jpmorgan.payments.models.epv1.*;
import com.app.jpmorgan.payments.api.AccountsApi;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.HttpServerErrorException;

public class Example {
  public static void main(String[] args) {

    // Configure Mutual TLS authentication and digital signing details: Certs
    MTLSConfiguration mtlsConfiguration = MTLSConfiguration.builder().mtlsCertLocation("certs/transportCert.p12")
            .certSigningPrivateKeyLocation("certs/private.key").mtlsCertPassword("credential of transport certificate")
            .build();

    // Use the above mTLS configuration to create a rest template
    RestTemplateConfigurer restTemplateConfigurer = new RestTemplateConfigurer();
    RestTemplate restTemplate = restTemplateConfigurer.restTemplate(mtlsConfiguration);

    // Create an APIClient (OpenAPI generated code) instance using the resttemplate that has mTLS configured above
    ApiClient apiClient = new ApiClient(restTemplate);

    // Set a base path for the api you are trying to reach to on the api client
    apiClient.setBasePath("https://apigatewaycat.jpmorgan.com/tsapi/ef/v1");

    try {
      // In this sample we are initializing accounts api (OpenAPI Generated code) to query a list of accounts
      AccountsApi accountsApi = new AccountsApi(apiClient);
      ListAccountsResponse listAccountsResponse = accountsApi.getAccounts(null, null, null, null);
      //..your business logic goes here
    } catch(HttpClientErrorException clientErrorException) {
        
      //Any 4xx response will result in a HttpClientErrorException, you can extract the error response like shown below
      ApiError apiError = clientErrorException.getResponseBodyAs(ApiError.class);
        
    } catch(HttpServerErrorException serverErrorException){

      //Any 5xx response will result in a HttpServerErrorException, you can extract the error response like shown below
      ApiError apiError = serverErrorException.getResponseBodyAs(ApiError.class);
      
    }


  }
}

```